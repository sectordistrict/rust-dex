{
    "borrow": {
        "introductory": "I handle borrowed data.",
        "traits": {
            "Borrow": {
                "implementor": [
                    "I have a borrowed version of myself that behaves the same way as me when hashed, compared, and ordered."
                ],
                "trait": [
                    "I can't be derived.",
                    "I was created to allow using keys that aren't owned variables for look ups in data structures like HashMaps. This is to avoid allocating new data on the heap just for a simple search, and instead only using a reference that's equivalent to the owned type and guarantees the same hash, this means for example, that a &str can be used when looking for a String in a HashMap.",
                    "I have a default implementation implemented for every type in Rust where the borrow() method returns the predictable normal reference to the type."
                ],
                "examples": [
                    "// Vec<i32>\n\tlet owned_key = vec![1, 2, 3];\n\t\n\t// &[i32], same values\n\tlet borrowed_version: &[i32] = &[1, 2, 3];\n\t\n\t// we create a Hash whose key type is Vec<i32>\n\tlet mut hash1: HashMap<Vec<i32>, i32> = HashMap::new();\n\t\n\t// we insert a Vec<i32> key\n\thash1.insert(owned_key, 2);\n\t\n\t// we look for that Vec<i32> using a &[i32]\n\t// and we successfully find it\n\t// because Vec implements Borrow<[T]>\n\tprintln!(\"{}\", hash1.get(borrowed_version).unwrap());"
                ]
            },
            "BorrowMut": {
                "implementor": [
                    "I can be mutably borrowed."
                ],
                "trait": [
                    "I can't be derived.",
                    "I have a default implementation implemented for every Type in Rust where the borrow_mut() method returns returns the normal predictable &mut Type."
                ],
                "examples": [
                    "// we define a Vec<i32>\n\tlet mut owned_vec = vec![1, 2, 3];\n\t\n\t// it can be mutably borrowed normally as &mut Vec<i32>\n\t// and this is the default BorrowMut implementation\n\tlet mut_borrow1: &mut Vec<i32> = owned_vec.borrow_mut();\n\t\n\t// but Vec also implements BorrowMut for [T]\n\t// so we can get a mutable reference to a [i32] by annotating the type\n\tlet mut_borrow2: &mut [i32] = owned_vec.borrow_mut();\n\t\n\t// this can also be achieved by writing this\n\tlet mut_borrow3: &mut [i32] = &mut owned_vec;\n\t\n\t// we can modify owned_vec using mut_borrow\n\tmut_borrow2[0] = 2;\n\t\n\t// it prints the modified Vec [2, 2, 3]\n\tprintln!(\"{:?}\", owned_vec);"
                ]
            },
            "ToOwned": {
                "implementor": [
                    "I can create an owned version of myself.",
                    "I can create that owned version either via cloning or different logic."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for borrowed types in Rust like str (to String) and [T] (to Vec).",
                    "I can't create or be part of a trait object because my methods include an additional Self requirement in the return and function parameters, this means we can't create the trait object because discerning the type of that Self parameter when creating the trait object is not possible.",
                    "I have a default implemention which just returns a cloned version of the type, and it's implemented for every type in Rust that implements Clone.",
                    "I'm a generalization of the Clone trait that works for any borrowed type."
                ],
                "examples": [
                    "// ToOwned is implemented for str\n\tlet string_slice = \"some\";\n\tlet owned_string: String = string_slice.to_owned();\n\t\n\t// ToOwned is implemented for i64\n\tlet some_number: i64 = 2;\n\tlet another_number: i64 = some_number.to_owned();\n\t\n\t// this won't compile\n\t// we can't create a trait object with ToOwned (not Object-Safe)\n\tfn func(argument: &dyn ToOwned) {}"
                ]
            }
        }
    },
    "clone": {
        "introductory": "I contain the trait for cloning",
        "traits": {
            "Clone": {
                "implementor": [
                    "An identical duplicate copy of me can be created using the .clone() method."
                ],
                "trait": [
                    "I can be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because the .clone() method returns Self, and as the compiler begins implementing the Clone trait for the trait object, it won't be able to satisfy the method returning Self, because Self then is the trait objects and trait objects are a Dynamically Sized type, and function return types must be Sized/have a size known at compile time.",
                    "I can have simple cloning logic or custom cloning logic depending on implementation."
                ],
                "examples": [
                    "#[derive(Debug, Clone)]\n\tstruct NumBox { num: i32 }\n\t\n\tlet numbox1 = NumBox { num: 3 };\n\tlet numbox2 = numbox1.clone();\n\t\n\tprintln!(\"{:?}\", numbox1); \n\tprintln!(\"{:?}\", numbox2); // Identical copy of numbox1"
                ]
            }
        }
    },
    "cmp": {
        "introductory": "I handle comparison and ordering traits",
        "traits": {
            "Eq": {
                "implementor": [
                    "I am capable of being compared with others of the same type using '==' and '!=' (.eq() and .ne()).",
                    "I don't have unsatisfied edge cases, equality is satisfied for every value that I can be.",
                    "I have PartialEq implemented."
                ],
                "trait": [
                    "I can be derived.",
                    "I'm an accessory to the PartialEq trait, I communicate to the compiler that the equality implementation infact satisfies all cases (No edgecase like NaNs in floating numbers).",
                    "I must be implemented along side PartialEq, but I do not add any new methods, I mainly just guarantee that the equality satisfies all cases.",
                    "HashMaps do not accept types that implement only PartialEq and not me, because they need that guarantee (that there are no edge cases)."
                ],
                "examples": [
                    "let mut hashmap = std::collections::HashMap::new();\n\n\t#[derive(PartialEq, Hash)]\n\tstruct NumBox1 { num: i32 }\n\t\n\tlet numbox1 = NumBox1 { num: 3 };\n\t\n\t// we can't insert a type that doesn't implement Eq in a HashMap\n\t// Error: the trait bound Numbox:Eq is not satisfied\n\thashmap.insert(numbox1, \"value\"); \n\n\n\t#[derive(PartialEq, Eq, Hash)]\n\tstruct NumBox2 { num: i32 }\n\t\n\tlet numbox2 = NumBox2 { num: 3 };\n\t\n\t// now it works because we implemented Eq\n\thashmap.insert(numbox2, \"value\"); "
                ]
            },
            "PartialEq": {
                "implementor": [
                    "I can be compared to some values of the same type as me using '==' and '!=' (.eq() and .ne()).",
                    "I have edge cases where the equality is not satisfied (If I also implement Eq then I don't have these edge cases)."
                ],
                "trait": [
                    "I can be derived.",
                    "I was created because the floating number NaN does not equal itself (this is the edge case), so I was created with a different name than Eq to communicate that I do not satisfy all cases of equality."
                ],
                "examples": [
                    "#[derive(PartialEq)]\n\tstruct NumBox {\n\t\tnum: i32,\n\t}\n\t\n\tlet numbox1 = NumBox { num: 3 };\n\tlet numbox2 = NumBox { num: 3 };\n\t\n\tprintln!(\"{}\", numbox1 == numbox2);   // true\n\tprintln!(\"{}\", numbox1 != numbox2);   // false\n\t\n\tprintln!(\"{}\", numbox1.eq(&numbox2)); // true\n\tprintln!(\"{}\", numbox1.ne(&numbox2)); // false"
                ]
            },
            "Ord": {
                "implementor": [
                    "I can be compared to some values of the same type as me using '>', '>=', '<', '<=', (.gt(), .ge(), .lt(), .le()).",
                    "I don't have comparison edge cases with values of the same type, I can be compared to every single value.",
                    "I have PartialOrd implemented."
                ],
                "trait": [
                    "I can be derived.",
                    "I'm an accessory to the PartialOrd trait, I communicate to the compiler that every value of a specific type is comparable to every other value of the same type (No edgecase like NaNs in floating numbers).",
                    "I must be implemented along side PartialOrd, but I do not add any new methods, I mainly just guarantee that the comparison is always valid.",
                    "Sorting does not work for types that implement only PartialOrd and not me, because they need that guarantee (that there are no edge cases)."
                ],
                "examples": [
                    "// we create an array of i32 numbers\n\tlet mut array_of_i32 = vec![1, 0, 32, 2, 3];\n\n\t// we create an array of f32 numbers\n\tlet mut array_of_f32 = vec![1.0, f32::NAN, 2.3];\n\n\t// i32 implements Ord and PartialOrd\n\t// this tells us that every single value in the type i32\n\t// is comparable to every single other value in i32\n\t// this means that there will be no problem sorting it\n\tarray_of_i32.sort();\n\tprintln!(\"{:?}\", array_of_i32); // prints [0, 1, 2, 3, 32]\n\t\n\t// f32 however Only implements PartialOrd (without Ord)\n\t// this tells us that there are some subset of f32 values\n\t// that are not comparable to other f32 values\n\t// this means that problems will rise up when we sort an f32 array\n\t// and it wont sort\n\tarray_of_f32.sort(); // compiler error\n\t\n\t// the reason f32 does not implement Ord along with PartialOrd\n\t// is because the floating number NAN compromises ordering\n\t// to understand how NAN compromises ordering\n\t// look at those two outputs\n\tprintln!(\"{:?}\", f32::NAN < 2.0); // prints false\n\tprintln!(\"{:?}\", f32::NAN > 2.0); // also prints false\n"
                ]
            },
            "PartialOrd": {
                "implementor": [
                    "I can be compared to some values of the same type as me using '>', '>=', '<', '<=', (.gt(), .ge(), .lt(), .le()).",
                    "There are value the same type as me that I can not be compared to (If I also implement Ord then this limitation no longer holds, and I can be compared to every value of my same type)."
                ],
                "trait": [
                    "I can be derived.",
                    "I was created because there are types where not all possible values from that type can be compared to each other, (there are some values of type A that can not be compared to other values also of type A), so I was created with a different name than Ord to communicate that I do not satisfy all the space of values for comparison.",
                    "PartialEq has to also be implemented for me to work."
                ],
                "examples": [
                    "// we create an array of i32 numbers\n\tlet mut array_of_i32 = vec![1, 0, 32, 2, 3];\n\n\t// we create an array of f32 numbers\n\tlet mut array_of_f32 = vec![1.0, f32::NAN, 2.3];\n\n\t// i32 implements Ord and PartialOrd\n\t// this tells us that every single value in the type i32\n\t// is comparable to every single other value in i32\n\t// this means that there will be no problem sorting it\n\tarray_of_i32.sort();\n\tprintln!(\"{:?}\", array_of_i32); // prints [0, 1, 2, 3, 32]\n\t\n\t// f32 however Only implements PartialOrd (without Ord)\n\t// this tells us that there are some subset of f32 values\n\t// that are not comparable to other f32 values\n\t// this means that problems will rise up when we sort an f32 array\n\t// and it wont sort\n\tarray_of_f32.sort(); // compiler error\n\t\n\t// the reason f32 does not implement Ord along with PartialOrd\n\t// is because the floating number NAN compromises ordering\n\t// to understand how NAN compromises ordering\n\t// look at those two outputs\n\tprintln!(\"{:?}\", f32::NAN < 2.0); // prints false\n\tprintln!(\"{:?}\", f32::NAN > 2.0); // also prints false\n"
                ]
            }
        }
    },
    "convert": {
        "introductory": "I handle conversion traits",
        "traits": {
            "AsMut": {
                "implementor": [
                    "I can be converted into a different type.",
                    "I return a mutable reference to the converted type.",
                    "I do not get consumed in conversion."
                ],
                "trait": [
                    "I can't be derived.",
                    "I'm the mutable version of the AsRef trait.",
                    "I am not related to the .as_mut() method implemented for Option and Result."
                ],
                "examples": [
                    "// we build an example around these two phrases both being possible:\n\t// \"situation has gone south\"\n\t// \"the direction you should go is south\"\n\n\t// we create direction types for a Geography struct\n\ttype South = bool;\n\ttype North = bool;\n\ttype East = bool;\n\ttype West = bool;\n\n\t// we create a Geography struct\n\t// which has our South type\n\tstruct Geography {\n\t\tsouth: South,\n\t\tnorth: North,\n\t\twest: West,\n\t\teast: East,\n\t}\n\n\t// we also create situation types for a Situation struct\n\t// and use the South type from above because\n\t// situations can also go south\"\n\ttype Good = bool;\n\n\t// Now we create the Situation struct\n\t// which has both the Good type, and the South type\n\tstruct Situation {\n\t\tgood: Good,\n\t\tsouth: South,\n\t}\n\n\t// we implement AsMut<South> for Geography\n\t// to make it convertable to a &mut South type\n\timpl AsMut<South> for Geography {\n\t\t// the as_mut method does not consume self\n\t\t// it takes &mut self\n\t\t// this is whats being referred to when AsMut is described as cheap\n\t\tfn as_mut(&mut self) -> &mut South {\n\t\t\t// we return a mutable reference to the inner south field in Geography\n\t\t\t&mut self.south\n\t\t}\n\t}\n\n\t// we also implement AsMut<South> for Situation\n\t// to make it convertable to a &mut South type\n\timpl AsMut<South> for Situation {\n\t\t// the as_mut method does not consume self\n\t\t// it takes &mut self\n\t\t// this is whats being referred to when AsMut is described as cheap\n\t\tfn as_mut(&mut self) -> &mut bool {\n\t\t\t// we return a mutable reference to the inner south field in situation\n\t\t\t&mut self.south\n\t\t}\n\t}\n\n\t// we create a function that accepts anything that\n\t// can be converted to a mutable south-like (a mutable reference of South)\n\tfn take_southable<T: AsMut<South>>(mut southable: T) {\n\t\t// now the conversion is inside this function in one place \n\t\tlet south: &mut South = southable.as_mut();\n\t\t// instead of Geography and Situation having to pass\n\t\t// Geography.south and Situation.south as arguments.\n\t\t// or in other conversion cases having to do more complex logic\n\t\t// this is a better alternative\n\t}\n\n\t// we create our situation and geography variables\n\n\tlet situation = Situation {\n\t\tgood: true,\n\t\tsouth: true,\n\t};\n\tlet geography = Geography {\n\t\tnorth: false,\n\t\twest: false,\n\t\teast: false,\n\t\tsouth: true,\n\t};\n\n\t// we can now do this which is much better\n\ttake_southable(situation);\n\ttake_southable(geography);\n\n\t// than this\n\ttake_southable(situation.south);\n\ttake_southable(geography.south);\n"
                ]
            },
            "AsRef": {
                "implementor": [
                    "I can be converted into a different type.",
                    "I return a reference to the converted type.",
                    "I do not get consumed in conversion."
                ],
                "trait": [
                    "I can't be derived.",
                    "I was created to make functions that require e.g. String as an argument more convenient by changing them to instead require \"convertable to String\".",
                    "This avoids having to instead convert every type prior to calling the function.",
                    "Those functions can simply call .as_ref() on whatever convertable-to-String they received to get the String out (reference to String).",
                    "And as a result have the much better ergonomics of the conversion happening in one line inside the function.",
                    "I am not related to the .as_ref() method implemented for Option and Result."
                ],
                "examples": [
                    "// we build an example around these two phrases both being possible:\n\t// \"situation has gone south\"\n\t// \"the direction you should go is south\"\n\n\t// we create direction types for a Geography struct\n\ttype South = bool;\n\ttype North = bool;\n\ttype East = bool;\n\ttype West = bool;\n\n\t// we create a Geography struct\n\t// which has our South type\n\tstruct Geography {\n\t\tsouth: South,\n\t\tnorth: North,\n\t\twest: West,\n\t\teast: East,\n\t}\n\n\t// we also create situation types for a Situation struct\n\t// and use the South type from above because\n\t// situations can also go south\"\n\ttype Good = bool;\n\n\t// Now we create the Situation struct\n\t// which has both the Good type, and the South type\n\tstruct Situation {\n\t\tgood: Good,\n\t\tsouth: South,\n\t}\n\n\t// we implement AsRef<South> for Geography\n\t// to make it convertable to a &South type\n\timpl AsRef<South> for Geography {\n\t\t// the as_ref method does not consume self\n\t\t// it takes &self\n\t\t// this is whats being referred to when AsRef is described as cheap\n\t\tfn as_ref(&self) -> &South {\n\t\t\t// we return a reference to the inner south field in Geography\n\t\t\t&self.south\n\t\t}\n\t}\n\n\t// we also implement AsRef<South> for Situation\n\t// to make it convertable to a &South type\n\timpl AsRef<South> for Situation {\n\t\t// the as_ref method does not consume self\n\t\t// it takes &self\n\t\t// this is whats being referred to when AsRef is described as cheap\n\t\tfn as_ref(&self) -> &bool {\n\t\t\t// we return a reference to the inner south field in situation\n\t\t\t&self.south\n\t\t}\n\t}\n\n\t// we create a function that accepts anything that\n\t// can be converted to a south-like (a reference of South)\n\tfn take_southable<T: AsRef<South>>(southable: T) {\n\t\t// now the conversion is inside this function in one place \n\t\tlet south: &South = southable.as_ref();\n\t\t// instead of Geography and Situation having to pass\n\t\t// Geography.south and Situation.south as arguments.\n\t\t// or in other conversion cases having to do more complex logic\n\t\t// this is a better alternative\n\t}\n\n\t// we create our situation and geography variables\n\n\tlet situation = Situation {\n\t\tgood: true,\n\t\tsouth: true,\n\t};\n\tlet geography = Geography {\n\t\tnorth: false,\n\t\twest: false,\n\t\teast: false,\n\t\tsouth: true,\n\t};\n\n\t// we can now do this which is much better\n\ttake_southable(situation);\n\ttake_southable(geography);\n\n\t// than this\n\ttake_southable(situation.south);\n\ttake_southable(geography.south);\n\n"
                ]
            },
            "From": {
                "implementor": [
                    "I can be created from a different type T (From<T>).",
                    "that type is consumed when it's converted to me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because I require the type I'm implemented for to have a Size known at compile time, and trait objects are Dynamically Sized Types, so the compiler will not be able to implement the From trait for the trait object. Additionally the .from() method returns Self, and as the compiler begins implementing the From trait for the trait object, it won't be able to satisfy the method returning Self, because Self then is the trait objects and trait objects are a Dynamically Sized type, and function return types must be Sized/have a size known at compile time.",
                    "I am the reciprocal of the Into trait.",
                    "The Into trait just uses me behind the scenes.",
                    "I must never fail."
                ],
                "examples": [
                    "// String implements From<&str>\n\t// so it can create itself from a &str\n\tlet Some_String = String::from(\"string_slice\");\n\n\t// prints the String\n\tprintln!(\"{}\", Some_String);"
                ]
            },
            "Into": {
                "implementor": [
                    "I can be converted into a type T (Into<T>).",
                    "I am consumed after conversion.",
                    "I can tell what type I'm converted into without needing a generic argument / turbofish (I can tell by inferring it from type annotations in the code)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because I require the type I'm implemented for to have a Size known at compile time, and trait objects are Dynamically Sized Types, so the compiler will not be able to implement the Into trait for the trait object.",
                    "I am the reciprocal of the From trait.",
                    "I am automatically implemented for any type that implements From.",
                    "I just use the .from() method from the From trait behind the scenes.",
                    "I must never fail."
                ],
                "examples": [
                    "// we create a i32\n\tlet num_i32: i32 = 2;\n\n\t// we convert it to a i64\n\t// .into() infers what type it's being converted into\n\t// from the type annotation \": i64\"\n\tlet num_i64: i64 = num_i32.into();"
                ]
            },
            "TryFrom": {
                "implementor": [
                    "I can be created from a T (TryFrom<T>).",
                    "that T is consumed when it's converted to me.",
                    "The operation of creating me might fail."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because I require the type I'm implemented for to have a Size known at compile time, and trait objects are Dynamically Sized Types, so the compiler will not be able to implement the TryFrom trait for the trait object. Additionally the .try_from() method has Self in its return, and as the compiler begins implementing the TryFrom trait for the trait object, it won't be able to satisfy the method returning Self, because Self then is the trait objects and trait objects are a Dynamically Sized type, and function return types must be Sized/have a size known at compile time.",
                    "I am the reciprocal of the TryInto trait.",
                    "The TryInto trait just uses me behind the scenes.",
                    "I allow failure, so I return a Result."
                ],
                "examples": [
                    "use std::convert::TryFrom;\n\n\t#[derive(Debug)]\n\tstruct GoldContainer { letter: String }\n\n\t// we implement TryFrom\n\timpl TryFrom<String> for GoldContainer {\n\t\ttype Error = String;\n\t\tfn try_from(string_slice: String) -> Result<Self, Self::Error> {\n\t\t\tif string_slice.contains(\"gold\") {\n\t\t\t\t// if our slice contains Gold \n\t\t\t\t// return a Result of Self containing that slice\n\t\t\t\tOk(Self {\n\t\t\t\t\tletter: string_slice,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// else we return an error\n\t\t\t\tErr(\"No gold\".to_owned())\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// we try to create a GoldContainer from our slice\n\t// we get a Result\n\tlet possible_gold = GoldContainer::try_from(\"gold\".to_owned());\n\t\n\t// we unwrap and it succeeds\n\tprintln!(\"{:?}\", possible_gold.unwrap());"
                ]
            },
            "TryInto": {
                "implementor": [
                    "I can be converted into a type T (TryInto<T>).",
                    "I am consumed after conversion.",
                    "The conversion operation might fail.",
                    "I can tell what type I'm converted into without needing a generic argument / turbofish.",
                    "I can infer that type from type annotations."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because I require the type I'm implemented for to have a Size known at compile time, and trait objects are Dynamically Sized Types, so the compiler will not be able to implement the TryInto trait for the trait object.",
                    "I am the reciprocal of the TryFrom trait.",
                    "I am automatically implemented for any type that implements From.",
                    "I just use the .try_from() method from the TryFrom trait behind the scenes.",
                    "I allow failure, so I return a Result."
                ],
                "examples": [
                    "// we don't need to implement TryInto\n\t// but it has to be in scope \n\tuse std::convert::{TryFrom, TryInto};\n\n\t#[derive(Debug)]\n\tstruct GoldContainer {\n\t\tletter: String,\n\t}\n\n\t// we implement TryFrom\n\t// TryInto is automatically implemented for us\n\t// by Rust\n\timpl TryFrom<String> for GoldContainer {\n\t\ttype Error = String;\n\t\tfn try_from(string_slice: String) -> Result<Self, Self::Error> {\n\t\t\tif string_slice.contains(\"gold\") {\n\t\t\t\t// if our slice contains Gold\n\t\t\t\t// return a Result of Self containing that slice\n\t\t\t\tOk(Self {\n\t\t\t\t\tletter: string_slice,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// else we return an error\n\t\t\t\tErr(\"No gold\".to_owned())\n\t\t\t}\n\t\t}\n\t}\n\n\t// we try to get a GoldContainer from our slice through TryInto\n\t// we get a Result\n\tlet string1 = \"gold\".to_owned();\n\tlet possible_gold: Result<GoldContainer, String> = string1.try_into();\n\n\t// we unwrap and it succeeds\n\tprintln!(\"{:?}\", possible_gold.unwrap());"
                ]
            }
        }
    },
    "string": {
        "introductory": "I deal with utf-8 strings",
        "traits": {
            "ToString": {
                "implementor": [
                    "I can be converted to a String using a .to_string() method that I provide."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am automatically implemented for any custom type if they implement the Display trait.",
                    "I can also be implemented for custom types in a custom way without the Display trait."
                ],
                "examples": [
                    "struct NumBox { num: i32 }\n\t\n\t// implementing Display for Numbox automatically implements ToString\n\t// ToString will use the conversion-to-string specified here\n\timpl Display for NumBox {\n\t\tfn fmt(...) {\n\t\t\t/*\n\t\t\timplementation that returns formatting-related results\n\t\t\tbut also includes code that converts numbox to String\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tlet numbox = NumBox { num: 3 };\n\t\n\t// now numbox can be displayed\n\tprintln!(\"{}\", numbox);\n\t\n\t// and can be converted to String\n\tlet numbox_as_string: String = numbox.to_string();\n\t\n\t// you can create a ToString implementation without the Display trait\n\t// but this will conflict with any Display implementation present\n\t// so it's either one or the other\n\timpl ToString for NumBox {\n\t\tfn to_string(...) { /* implementation that returns a String */ }\n\t}\n\t\n\t// now numbox can be converted to a String without the Display trait\n\tlet numbox_as_string: String = numbox.to_string();"
                ]
            }
        }
    },
    "fmt": {
        "introductory": "I deal with String formatting",
        "traits": {
            "Display": {
                "implementor": [
                    "I can be used in print functions to substitute the \"{}\" part of the formatting.",
                    "I can be converted to a String, via the automatic ToString implementation that comes with me having the Display trait."
                ],
                "trait": [
                    "I can't be derived.",
                    "If I am implemented for a type, Rust automatically implements ToString for that type."
                ],
                "examples": [
                    "struct NumBox { num: i32 }\n\t\n\t// implementing Display for Numbox automatically implements ToString\n\t// ToString will use the conversion-to-string specified here\n\timpl Display for NumBox {\n\t\tfn fmt(...) {\n\t\t\t/*\n\t\t\timplementation that returns formatting-related results\n\t\t\tbut also includes code that converts numbox to String\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tlet numbox = NumBox { num: 3 };\n\t\n\t// now numbox can be displayed\n\tprintln!(\"{}\", numbox);\n\t\n\t// and can be converted to a String\n\tlet numbox_as_string: String = numbox.to_string();"
                ]
            },
            "Debug": {
                "implementor": [
                    "I can be used in print functions to substitute the \"{:?}\" part or \"{#?}\" for pretty-printing."
                ],
                "trait": [
                    "I can be derived.",
                    "I am usually derived but I can also be implemented in a custom way."
                ],
                "examples": [
                    "// because Debug is derivable \n\t// we don't need manually implement the trait\n\t#[derive(Debug)]\n\tstruct NumBox {\n\t\tnum: i32,\n\t}\n\n\t// we create our variable numbox\n\tlet numbox = NumBox { num: 3 };\n\n\t// now numbox can be printed using {:?}\n\tprintln!(\"{:?}\", numbox);\n\t\n\t// as well as using {:#?} for pretty printing\n\tprintln!(\"{:#?}\", numbox);\n"
                ]
            },
            "Binary": {
                "implementor": [
                    "I can be printed as binary with print functions using {:b}.",
                    "I can also be printed using {:#b} (adds 0b infront of the binary).",
                    "If I am a negative number I will be printed using two's complement representation (reverse all zeros and ones, and then add one to the beginning)."
                ],
                "trait": [
                    "I can't be derived."
                ],
                "examples": [
                    "println!(\"{:b}\", 2);   // binary representation: 10\n\t\n\tprintln!(\"{:#b}\", 2);  // same but appends 0b: 0b10\n\t\n\tprintln!(\"{:b}\", -2);  // two's complement representation\n\t// 11111111111111111111111111111110\n\t\n\tprintln!(\"{:#b}\", -2); // same but appends 0b\n\t// 0b11111111111111111111111111111110"
                ]
            },
            "LowerExp": {
                "implementor": [
                    "I can be printed with scientific number notation using {:e}. (1200 becomes 1.2e3)"
                ],
                "trait": [
                    "I can't be derived."
                ],
                "examples": [
                    "println!(\"{:e}\", 1200000000);   // outputs \"1.2e9\""
                ]
            },
            "LowerHex": {
                "implementor": [
                    "I can be printed in hexadecimal with print functions using {:x}.",
                    "I can also be printed using {:#x} (adds 0x infront of the hex representation).",
                    "If I am a negative number I will be printed using two's complement representation (equivalent to the binary version: reverse all zeros and ones, and then add one to the beginning)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I'm the lower case version of the UpperExp trait."
                ],
                "examples": [
                    "println!(\"{:x}\", 168);  // hex representation: a8\n\tprintln!(\"{:#x}\", 168); // same but appends 0x: 0xa8\n\t\n\tprintln!(\"{:x}\", 2);   // positive number: 2\n\tprintln!(\"{:x}\", -2);  // negative number: fffffffe"
                ]
            },
            "Octal": {
                "implementor": [
                    "I can be printed in Octal representation with print functions using {:o}.",
                    "I can also be printed using {:#o} (adds 0o infront of the octal representation).",
                    "If I am a negative number I will be printed using two's complement representation (equivalent to the binary version: reverse all zeros and ones, and then add one to the beginning)."
                ],
                "trait": [
                    "I can't be derived."
                ],
                "examples": [
                    "println!(\"{:o}\", 168);  // octal representation: 250\n\tprintln!(\"{:#o}\", 168); // same but appends 0o: 0o250\n\t\n\tprintln!(\"{:o}\", 2);   // positive number: 2\n\tprintln!(\"{:o}\", -2);  // negative number: 37777777776"
                ]
            },
            "Pointer": {
                "implementor": [
                    "My memory address can be printed as a hexadecimal value with print functions using {:p}.",
                    "I can also be printed using {:#p} (this includes leading zeros in the pointer)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I'm only implemented for pointer types."
                ],
                "examples": [
                    "let number = 2;\n\tprintln!(\"{:p}\", number);        // doesn't work, must provide an address\n\tprintln!(\"{:p}\", &number);        // outputs pointer memory address\n\tprintln!(\"{:#p}\", &number);       // same but with leading zeros included\n\t\n\tlet string_slice = \"str\";\n\tprintln!(\"{:#p}\", string_slice);  // a string slice is a pointer\n\t\n\tstruct NumBox { num: i32 }\n\tlet numbox = NumBox { num: 3 };\n\tprintln!(\"{:#p}\", &numbox);       // pointer to a struct"
                ]
            },
            "UpperExp": {
                "implementor": [
                    "I can be printed with scientific number notation using {:E}. (1200 becomes 1.2E3)"
                ],
                "trait": [
                    "I can't be derived.",
                    "I'm the capital letter version of the LowerExp trait."
                ],
                "examples": [
                    "println!(\"{:E}\", 1200000000);   // outputs \"1.2E9\""
                ]
            },
            "UpperHex": {
                "implementor": [
                    "I can be printed in hexadecimal with print functions using {:X}.",
                    "I can also be printed using {:#X} (adds 0x infront of the hex representation).",
                    "If I am a negative number I will be printed using two's complement representation (equivalent to the binary version: reverse all zeros and ones, and then add one to the beginning)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I'm the capital letter version of the LowerHex trait."
                ],
                "examples": [
                    "println!(\"{:X}\", 168);  // hex representation: A8\n\tprintln!(\"{:#X}\", 168); // same but appends 0x: 0xA8\n\t\n\tprintln!(\"{:X}\", 2);   // positive number: 2\n\tprintln!(\"{:X}\", -2);  // negative number: FFFFFFFE"
                ]
            },
            "Write": {
                "implementor": [
                    "I can accept UTF-8 data to be written into me.",
                    "I can accept that data via a &str (string slice) using .write_str()",
                    "I can accept that data via a char using .write_char()",
                    "I can accept that data via a formatted string using .write_fmt()"
                ],
                "trait": [
                    "I can't be derived.",
                    "I'm simply a constrained version of std::io::Write that only writes UTF-8.",
                    "I also don't have the capability of flushing the buffer I'm writing into like std::io::Write."
                ],
                "examples": [
                    "// Strings implement this trait\n\t// so they can accpet UTF-8 data written into them\n\tlet mut string = String::new(); \n\t\n\tstring.write_str(\"s\").unwrap(); // written into via a string slice   \n\t\n\tstring.write_char('s').unwrap(); // written into via a char\n\t\n\tstring.write_fmt(format_args!(\"{}\", 22)).unwrap(); // via a formatted string "
                ]
            }
        }
    },
    "io": {
        "introductory": "I deal with input/output",
        "traits": {
            "IsTerminal": {
                "implementor": [
                    "I can be interrogated to whether I am a terminal or not by using the .is_terminal() method."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for IO types."
                ],
                "examples": [
                    "// these return linux std handles\n\tlet stdin = io::stdin();\n\tlet stdout = io::stdout();\n\tlet stderr = io::stderr();\n\t\n\tlet _: bool = stdin.is_terminal(); // returns a boolean\n\tlet _: bool = stdout.is_terminal(); // returns a boolean\n\tlet _: bool = stderr.is_terminal(); // returns a boolean"
                ]
            },
            "Read": {
                "implementor": [
                    "I'm a Rust representation of an outside data source of some form (e.g. stdin, a file) that can be read.",
                    "I take a buffer as an argument, and have my data read through that buffer, by outputting bytes into it."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for \"inwards travelling\"/\"input\" IO and Network types (e.g. stdin).",
                    "I do not provide an internal buffer like the BufRead trait, I have to be provided one.",
                    "I'm a purer version of io::BufRead that does not use an internal buffer to handle different situations for me."
                ],
                "examples": [
                    "// this gives us the stdin handle which implements Read\n\tlet stdin_ = std::io::stdin();\n\tlet mut stdin = stdin_.lock();\n\n\t// we create our buffer\n\tlet mut buffer: [u8; 10] = [0; 10];\n\\n\t// and loads that data into our buffer\n\tstdin.read(&mut buffer).unwrap();\n\n\t// prints what we got in the buffer\n\tprintln!(\"{buffer:?}\");\n"
                ]
            },
            "BufRead": {
                "implementor": [
                    "I'm a Rust representation of an outside data source of some form (e.g. stdin, a file) that can be read.",
                    "I have an internal buffer where I can receive bytes from that outside source using the .fill_buf() method.",
                    "The .fill_buf() method fills its internal buffer with data from that source, and then reads the data from the buffer and returns it as bytes slice.",
                    "I do not automatically empty the buffer once it's read, I must explicitly call the .consume() method to empty it."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for \"inwards travelling\"/\"input\" IO and Network types (e.g. stdin).",
                    "I'm a more useful version of io::Read that utilizes an internal buffer to handle different situations more efficiently."
                ],
                "examples": [
                    "// this gives us the stdin handle which implements BufRead\n\tlet stdin_ = std::io::stdin();\n\tlet mut stdin = stdin_.lock();\n\t\n\t// this fills the internal buffer with whatever input stdin receives\n\t// and loads that data into our data variable\n\tlet data = stdin.fill_buf().unwrap();\n\t\n\t// prints the data\n\tprintln!(\"{data:?}\");\n\t\n\t// because the internal buffer wasn't emptied (wasn't consumed) \n\t// our data variable is again filled with the same earlier input\n\t// this is because we didn't explicitly empty the internal buffer\n\t// (the stdin will remain blocked from further input\n\t// until we empty the internal buffer)\n\tlet data = stdin.fill_buf().unwrap();\n\t\n\t// prints the same previous input \n\t// because .consume() was not called to empty the internal buffer \n\tprintln!(\"{data:?}\");\n\t\n\t// now we call .consume() to consume the internal buffer (emptying it)\n\tlet length = data.len();\n\tstdin.consume(length);\n\t\n\t// now the internal buffer is empty \n\t// so .fill_buf() will wait for new input to fill the internal buffer\n\tlet data = stdin.fill_buf().unwrap();\n\t\n\t// and once it's filled this print will then run\n\t// prints the new user input\n\tprintln!(\"{data:?}\");"
                ]
            },
            "Seek": {
                "implementor": [
                    "I can decide the specific starting point/location of the byte where I'm reading or writing, via a cursor that I provide using the .seek() method.",
                    "I can specify a displacement count from the beginning or end of the bytes stream where I can move the Read and Write cursor."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for general    IO and Network types."
                ],
                "examples": [
                    "let mut file = File::open(\"readme.txt\").unwrap();\n\t\n\t// this moves the read and write cursor 42 bytes forward\n\t// .seek() uses an Enum (SeekFrom) provided by the io module\n\tfile.seek(SeekFrom::Start(42)).unwrap();\n\t\n\t// now reading and writing will read and write beginning from the 42nd byte \n\t\n\t// ...read and write code"
                ]
            },
            "Write": {
                "implementor": [
                    "I'm a Rust representation of an outside data sink of some form (e.g. stdout, TcpStream).",
                    "I can accept any bytes to be written into me using the .write() method.",
                    "I have a buffer that stores all that is written into me.",
                    "I can flush that buffer to have it's contents immediately leave for that outside data sink using the .flush() method."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for \"outwards travelling\" IO and Network types (e.g. stdout, not stdin).",
                    "I'm a general version of std::fmt::Write that writes any byte, and is not constrained to UTF-8 data.",
                    "Rust decides on its own (based on the size of the data) when to output the data that was written to the .write() method. The purpose of .flush() is to not rely on that and to instead immediately flush the data on the line where flush is written."
                ],
                "examples": [
                    "use std::io::Write;\n\t\n\t// this gets us the stdout handle, which implements Write by default\n\tlet mut stdout = io::stdout();\n\t\n\t// the write function writes and then returns a result of the number of bytes written\n\tlet _ = stdout.write(\"some \".as_bytes());\n\t\n\t// sleeping for 2 seconds to show that the data \n\t// is not necessarilly immediately outputted to stdout\n\tsleep(Duration::from_millis(2000));\n\t\n\t// flushing the data, this immediately sends it to stdout\n\tstdout.flush().unwrap();\n\t\n\t// again, writing immediately after flushing above \n\t// doesnt necessarilly write immediately to stdout\n\tlet _ = stdout.write(\" bytes\".as_bytes());\n\t\n\t// sleeping for two seconds, and \" bytes\" was still not outputted after \"some\"\n\tsleep(Duration::from_millis(2000));\n\t\n\t// \" bytes\" flushed by force\n\tstdout.flush().unwrap();"
                ]
            }
        }
    },
    "iter": {
        "introductory": "I handle iteration traits",
        "traits": {
            "DoubleEndedIterator": {
                "implementor": [
                    "I'm an Iterator that can be iterated over from the end and going back.",
                    "I also have a next_back() function that allows me to do that.",
                    "Like the iterator trait and by convention, The iteration is done when I return the first None from either side (For loops for example, will stop iterating over me after the first None), but the DoubleEndedIterator trait itself does not enforce that, as there are some iteration applications that directly utilize the capability of outputting alternating None and Some outputs."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for most Iterator types."
                ],
                "examples": [
                    "// we create an iterator from a vector\n\t// vector iterators implement DoubleEndedIterator\n\tlet mut vector_iterator = vec![1, 2, 3, 4].into_iter();\n\n\tprintln!(\"{:?}\", vector_iterator.next().unwrap()); // prints 1\n\tprintln!(\"{:?}\", vector_iterator.next_back().unwrap()); // prints 4\n\tprintln!(\"{:?}\", vector_iterator.next().unwrap()); // prints 2\n\tprintln!(\"{:?}\", vector_iterator.next_back().unwrap()); // prints 3\n"
                ]
            },
            "ExactSizeIterator": {
                "implementor": [
                    "I'm an Iterator that knows its size."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for most Iterator types."
                ],
                "examples": [
                    "// we create two iterators\n\tlet mut map = vec![1, 2, 3].into_iter().map(|item| item);\n\tlet mut scan = vec![1, 2, 3].into_iter().scan(0, |_, item| Some(item));\n\n\t// map implements ExactSizedIterator\n\t// so we can see its length\n\tprintln!(\"{:?}\", map.len()); // prints 3\n\t\n\t// scan does not implements ExactSizedIterator\n\t// so the following does not work\n\tprintln!(\"{:?}\", scan.len()); // compile error\n"
                ]
            },
            "Extend": {
                "implementor": [
                    "My inner contents can be extended using any type that's iterable (I don't have to be an iterator)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because the extend() function is generic and trait object vtables do not handle monomorphization.",
                    "I am implemented for most std collection types and container types like String and Vec"
                ],
                "examples": [
                    "// we create our new type\n\t#[derive(Debug)]\n\tstruct List(Vec<i32>);\n\n\t// we implement the Extend trait for our type\n\timpl std::iter::Extend<i32> for List {\n\t\t// we implement the extend method\n\t\t// it takes any type that can be turned into an iterator\n\t\t// meaning any type that implements the IntoIterator trait\n\t\t// and then extends our List with the contents of that type\n\t\tfn extend<T: IntoIterator<Item = i32>>(&mut self, iter: T) {\n\t\t\t// we use the extend method for Vecs to extend the List\n\t\t\t// because our List is just a thin wrapper\n\t\t\tself.0.extend(iter);\n\t\t}\n\t}\n\n\t// we now create an initial list\n\tlet mut list = List(vec![0, 1]);\n\n\t// we extend it using a range\n\t// (ranges implement Into Iterator)\n\t// so this works\n\tlist.extend(2..4);\n\n\t// we extend it again using a vec\n\t// (Vecs implement Into Iterator)\n\t// so this works\n\tlist.extend(vec![4, 5]);\n\n\t// list is now extended\n\tprintln!(\"{:?}\", list); // prints List([0, 1, 2, 3, 4, 5])\n"
                ]
            },
            "FusedIterator": {
                "implementor": [
                    "I'm an iterator that indefinitely returns None after the first None that I return.",
                    "I continue to to return None even if some Some values exist after the first None."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for almost all Iterator types."
                ],
                "examples": [
                    "// we create an iterator \n\t// by using an increasing range from 0 to 9 \n\t// and returning Some everywhere \n\t// except for when the value is 4\n\t// meaning we will have continuos Some values\n\t// and one None in the middle\n\tlet mut iterator = (0..10).scan(0, |_, item| {\n\t\tif item == 4 {\n\t\t\treturn None;\n\t\t} else {\n\t\t\treturn Some(item);\n\t\t}\n\t});\n\n\t// We fuse the iterator\n\tlet mut iterator_fused = iterator.fuse();\n\t\n\t// Now we continue to call next()\n\tprintln!(\"{:?}\", iterator_fused.next()); // returns Some(0)\n\tprintln!(\"{:?}\", iterator_fused.next()); // Some(1)\n\tprintln!(\"{:?}\", iterator_fused.next()); // Some(2)\n\tprintln!(\"{:?}\", iterator_fused.next()); // Some(3)\n\tprintln!(\"{:?}\", iterator_fused.next()); // None \n\tprintln!(\"{:?}\", iterator_fused.next()); // None despite having Some values left\n\tprintln!(\"{:?}\", iterator_fused.next()); // None despite having Some values left\n\tprintln!(\"{:?}\", iterator_fused.next()); // None despite having Some values left\n"
                ]
            },
            "Iterator": {
                "implementor": [
                    "I can be iterated over.",
                    "I have a next() function that allows iteration over me.",
                    "I specify an internal item which is the main value to be iterated over.",
                    "I am lazily evaluated, meaning I don't actually get iterated over unless the next() function is called.",
                    "By convention, The iteration is done when I return the first None (For loops for example, will stop iterating over me after the first None), but the Iterator trait itself does not enforce such a rule as there are some iteration applications that directly utilize the capability of outputting alternating None and Some outputs."
                ],
                "trait": [
                    "I can't be derived."
                ],
                "examples": [
                    "let values = vec![1, 2, 3];\n\n\t// this doesn't do anything (iterators are lazy)\n\tvalues.iter().map(|value| value + 1);\n\t\n\t// Now it's evaluated (the collect function forces the iteration)\n\tlet b = values.iter().map(|value| value + 1).collect::<Vec<i32>>();"
                ]
            },
            "Product": {
                "implementor": [
                    "I'm the internal item inside an iterator, and I can be multiplied with each of the other entries inside the iterator into one result."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because the product() function is not a method (does not take self as an argument), and because of that, can not be distinguished nor be accessed at runtime by the trait object, I also require that the types I'm implemented for must be Sized/have a size known at compile time, and therefore I cant be made into a trait object, because trait objects are not sized (Dynamically Sized Type) and they have to implement the trait, and even if those rules weren't broken, the .sum() function returns Self, which also breaks Object Safety rules.",
                    "I am implemented for all numeric primitives like i32, f64, ..etc and therefore all iterators whose internal types are these types can call sum()."
                ],
                "examples": [
                    "// we create our new type\n\t#[derive(Debug)]\n\tstruct num(i32);\n\n\t// we implement Product for our type\n\timpl std::iter::Product for num {\n\t\t// we implement the product function\n\t\tfn product<I>(iter: I) -> Self\n\t\twhere\n\t\t\tI: Iterator<Item = Self>,\n\t\t{\n\t\t\t// we multiply all of the nums\n\t\t\t// that are in the iterator\n\t\t\t// into one num\n\t\t\titer.into_iter()\n\t\t\t\t.fold(num(1), |acc, item| num(acc.0 * item.0))\n\t\t}\n\t}\n\n\t// we create an iterator that has num as an internal type\n\tlet vector = vec![num(10), num(10), num(10)].into_iter();\n\n\t// we call the product function\n\tprintln!(\"{:?}\", vector.product::<num>()); // prints num(1000)\n"
                ]
            },
            "Sum": {
                "implementor": [
                    "I'm the internal item inside an iterator, and I can be summed along with the other entries inside the iterator into one result."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because the sum() function is not a method (does not take self as an argument), and because of that, can not be distinguished and also can not be accessed at runtime by the trait object, I also require that the types I'm implemented for must be Sized/have a size known at compile time, and therefore I cant be made into a trait object, because trait objects are not sized (Dynamically Sized Type) and they have to implement the trait, and even if those rules weren't broken, the .sum() function returns Self, which also breaks Object Safety rules.",
                    "I am implemented for all numeric primitives like i32, f64, ..etc and therefore all iterators whose internal types are these types can call sum()."
                ],
                "examples": [
                    "// we create our new type\n\t#[derive(Debug)]\n\tstruct num(i32);\n\n\t// we implement Sum for our type\n\timpl std::iter::Sum for num {\n\t\t// we implement the sum function\n\t\tfn sum<I>(iter: I) -> Self\n\t\twhere\n\t\t\tI: Iterator<Item = Self>,\n\t\t{\n\t\t\t// we sum all of the nums \n\t\t\t// that are in the iterator \n\t\t\t// into one num\n\t\t\titer.into_iter()\n\t\t\t\t.fold(num(0), |acc, item| num(acc.0 + item.0))\n\t\t}\n\t}\n\n\t// we create an iterator that has num as an internal type\n\tlet vector = vec![num(10), num(10), num(10)].into_iter();\n\n\t// we call the sum function \n\tprintln!(\"{:?}\", vector.sum::<num>()); // prints num(30)"
                ]
            },
            "FromIterator": {
                "implementor": [
                    "I can create myself from an Iterator.",
                    "the collect function can collect into me using a turbofish."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because I require the type I'm implemented for to have a Size known at compile time, and trait objects are Dynamically Sized Types, so the compiler will not be able to implement the FromIterator trait for the trait object. Additionally the .from_iter() method returns Self, and as the compiler begins implementing the FromIterator trait for the trait object, it won't be able to satisfy the method returning Self, because Self then is the trait objects and trait objects are a Dynamically Sized type, and function return types must be Sized/have a size known at compile time.",
                    "the collect function can collect into me using a turbofish"
                ],
                "examples": [
                    "// create an iterator\n\tlet iterator = vec![(1, 0), (2, 0), (3, 0)].into_iter();\n\n\t// create a HashMap from the iterator\n\tlet hashmap: HashMap<i32, i32> = HashMap::from_iter(iterator);\n\n\t// create a HashMap from the iterator using collect()\n\tlet hashmap2 = vec![(1, 0), (2, 0), (3, 0)]\n\t\t.into_iter()\n\t\t.collect::<HashMap<i32, i32>>();"
                ]
            },
            "IntoIterator": {
                "implementor": [
                    "I can be converted into an iterator.",
                    "I have access to an into_iter() method that does that.",
                    "for loops can iterate over me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for most data structures in Rust.",
                    "I am automatically implemented for any type in Rust that implements the Iterator trait."
                ],
                "examples": [
                    "// We create a type to implement IntoIterator for\n\tstruct Counter {\n\t\tcount: Vec<i32>,\n\t}\n\n\t// We implement   IntoIterator for Counter\n\timpl IntoIterator for Counter {\n\t\ttype Item = // Implementation detail\n\t\ttype IntoIter = // Implementation detail\n\t\tfn into_iter(self) -> Self::IntoIter {\n\t\t\t// Implementation\n\t\t}\n\t}\n\t\n\t// We create our counter variable\n\tlet counter = Counter { count: vec![1, 2, 3] };\n\t\n\t// Now it can function like an iterator\n\tfor count in counter {\n\t\t// Do something\n\t}\n"
                ]
            }
        }
    },
    "marker": {
        "introductory": "We are \"primitive traits\", meaning we act as foundational signifiers that do not actually provide any methods, we simply give you insight about what you should expect from our implementors",
        "traits": {
            "Copy": {
                "implementor": [
                    "I don't change ownership/get \"moved\" when I am assigned from an old variable to a new variable.",
                    "Instead I get copied bit by bit behind the scenes to the new variable via memcpy, and the old variable can still be used."
                ],
                "trait": [
                    "I can be derived.",
                    "Clone has to also be implemented for me to work."
                ],
                "examples": [
                    "#[derive(Debug, Copy, Clone)]\n\tstruct NumBox { num: i32 }\n\t\n\tlet numbox1 = NumBox { num: 3 };\n\tlet numbox2 = numbox1;\n\t\n\tprintln!(\"{:?}\", numbox1); // numbox1 still prints, it wasn't moved\n\tprintln!(\"{:?}\", numbox2); // copy of numbox1 without needing .clone()"
                ]
            },
            "Sized": {
                "implementor": [
                    "My size is known at compile time.",
                    "I can be stored in the stack, but if I am too large I will cause stack overflow."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am automatically implemented for almost every type in Rust.",
                    "The stack only stores variable that are Sized.",
                    "When you want to specify some type as explicity not sized, the ?Sized notation is used.",
                    "?Sized types can not be stored in the stack.",
                    "?Sized variables are called Dynamically Sized Types."
                ],
                "examples": [
                    "// argument allowed, size known at compile time\n\t// explicitly stated array size (3)\n\tfn func1(array: [u8; 3]) { ... }  \n\t\n\t// argument allowed, it's not known at compile time \n\t// but it's behind a reference \n\t// which has a known size of usize \n\tfn func2(array: &[u8]) { ... }  \n\t\n\t// will not compile, argument size not known at compile time \n\t// array could be any length\n\tfn func3(array: [u8]) { ... }\n\n\t// this reads: (function that takes any argument that's not sized)\n\t// which will not compile because the size is not known\n\tfn func4(some_argument: impl ?Sized) { ... }\n\n\t// will compile because the size is known at compile time\n\t// but will error and exit immediately due to stack overflow\n\t// array size too large and overflows the stack\n\tlet array = [0; 10000000];"
                ]
            }
        }
    },
    "ops": {
        "introductory": "I handle operators",
        "traits": {
            "Add": {
                "implementor": [
                    "I can be added to myself using the + sign or the add() method.",
                    "I can also be added to any specific type, and not only myself, as it dependes on how Add was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of addition, as that also dependes on how Add was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Add trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the + sign / the thing that will be added)\n\t// as Vector2D, meaning we implement adding it only to itself\n\timpl Add<Vector2D> for Vector2D {\n\t\t\n\t\t// we specify the type of the output of the addition \n\t\ttype Output = Vector2D;\n\n\t\t// we implement the add() method \n\t\tfn add(self, rhs: Self) -> Self::Output {\n\t\t\tVector2D(self.0 + rhs.0, self.1 + rhs.1)\n\t\t}\n\t}\n\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now add a Vector2D to it\n\t// because we implemented Add<Vector2D>\n\tprintln!(\"{:?}\", a + Vector2D(1, 2)); // outputs Vector2D(2, 4)\n\tprintln!(\"{:?}\", a.add(Vector2D(1, 2))); // outputs Vector2D(2, 4)\n\n\t// but this won't work\n\t// because we didn't implement Add<i32>\n\tprintln!(\"{:?}\", a + 2); // compiler error\n\tprintln!(\"{:?}\", a.add(2)); // compiler error"
                ]
            },
            "Sub": {
                "implementor": [
                    "I can be subtracted from myself using the - sign or the sub() method.",
                    "Any other specific type can also be subtracted from me, and not only myself, as it dependes on how Sub was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of subtraction, as that also dependes on how Sub was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Sub trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the - sign / the thing that will be subtracted)\n\t// as Vector2D, meaning we implement subtracting it only by itself\n\timpl Sub<Vector2D> for Vector2D {\n\t\t\n\t\t// we specify the type of the output of the subtraction \n\t\ttype Output = Vector2D;\n\n\t\t// we implement the sub() method \n\t\tfn sub(self, rhs: Self) -> Self::Output {\n\t\t\tVector2D(self.0 - rhs.0, self.1 - rhs.1)\n\t\t}\n\t}\n\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now subtract a Vector2D from it\n\t// because we implemented Sub<Vector2D>\n\tprintln!(\"{:?}\", a - Vector2D(1, 2)); // outputs Vector2D(0, 0)\n\tprintln!(\"{:?}\", a.sub(Vector2D(1, 2))); // outputs Vector2D(0, 0)\n\n\t// but this won't work\n\t// because we didn't implement Sub<i32>\n\tprintln!(\"{:?}\", a - 2); // compiler error\n\tprintln!(\"{:?}\", a.sub(2)); // compiler error\n"
                ]
            },
            "Div": {
                "implementor": [
                    "I can be divided by myself using the / sign or the div() method.",
                    "I can also be divided by any other specific type, and not only myself, as it dependes on how Div was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of division, as that also dependes on how Div was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Div trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"/\" sign / the thing that we will divide by)\n\t// as Vector2D, meaning we implement division for it only by itself\n\timpl Div<Vector2D> for Vector2D {\n\t\t\n\t\t// we specify the type of the output of the division\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the div() method \n\t\tfn div(self, rhs: Self) -> Self::Output {\n\t\t\tVector2D(self.0 / rhs.0, self.1 / rhs.1)\n\t\t}\n\t}\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now divide it by a Vector2D\n\t// because we implemented Div<Vector2D>\n\tprintln!(\"{:?}\", a / Vector2D(1, 2)); // outputs Vector2D(1, 1)\n\tprintln!(\"{:?}\", a.div(Vector2D(1, 2))); // outputs Vector2D(1, 1)\n\n\t// but this won't work\n\t// because we didn't implement Div<i32>\n\tprintln!(\"{:?}\", a / 2); // compiler error\n\tprintln!(\"{:?}\", a.div(2)); // compiler error\n"
                ]
            },
            "Mul": {
                "implementor": [
                    "I can multiply by myself using the * sign or the mul() method.",
                    "I can also multiply by any other specific type, and not only myself, as it dependes on how Mul was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of multiplication, as that also dependes on how Mul was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Mul trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the * sign / the thing that we will multiply by)\n\t// as Vector2D, meaning we implement multiplication for it only by itself\n\timpl Mul<Vector2D> for Vector2D {\n\t\t\n\t\t// we specify the type of the output of the multiplication\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the mul() method \n\t\tfn mul(self, rhs: Self) -> Self::Output {\n\t\t\tVector2D(self.0 * rhs.0, self.1 * rhs.1)\n\t\t}\n\t}\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now multiply it by a Vector2D\n\t// because we implemented Mul<Vector2D>\n\tprintln!(\"{:?}\", a * Vector2D(1, 2)); // outputs Vector2D(1, 4)\n\tprintln!(\"{:?}\", a.mul(Vector2D(1, 2))); // outputs Vector2D(1, 4)\n\n\t// but this won't work\n\t// because we didn't implement Mul<i32>\n\tprintln!(\"{:?}\", a * 2); // compiler error\n\tprintln!(\"{:?}\", a.mul(2)); // compiler error\n\n"
                ]
            },
            "Rem": {
                "implementor": [
                    "I am capable of finding the remainder of my division with another value using the % sign or the rem() method.",
                    "I can use the remainder operator with any type, and not only myself, as it dependes on how Rem was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of the remainder operation, as that also dependes on how Rem was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Rem trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the % sign / the thing that we will divide by)\n\t// as Vector2D, meaning we implement it to only divide by itself\n\timpl Rem<Vector2D> for Vector2D {\n\t\t\n\t\t// we specify the type of the output of the remainder operation\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the rem() method \n\t\tfn rem(self, rhs: Self) -> Self::Output {\n\t\t\tVector2D(self.0 % rhs.0, self.1 % rhs.1)\n\t\t}\n\t}\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now find the remainder with a Vector2D\n\t// because we implemented Rem<Vector2D>\n\tprintln!(\"{:?}\", a % Vector2D(1, 2)); // outputs Vector2D(0, 0)\n\t// println!(\"{:?}\", a.rem(Vector2D(1, 2))); // outputs Vector2D(0, 0)\n\n\t// but this won't work\n\t// because we didn't implement Rem<i32>\n\t// println!(\"{:?}\", a % 2); // compiler error\n\t// println!(\"{:?}\", a.rem(2)); // compiler error\n"
                ]
            },
            "Shl": {
                "implementor": [
                    "I can be left shifted using the << sign or the shl() method.",
                    "I can also be left shifted using any other specific type, and not only myself, as it dependes on how Shl was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of left shifting, as that also dependes on how Shl was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Shl trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"<<\" sign)\n\t// as Vector2D, meaning we can only left shift it with a value of the same type\n\timpl Shl<i32> for Vector2D {\n\t\t// we define the output to be Vector2D\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the shl() method which takes an owned self\n\t\tfn shl(self, rhs: i32) -> Self::Output {\n\t\t\tVector2D(self.0 << rhs, self.1 << rhs)\n\t\t}\n\t}\n\n\t// we create our vector to left shift it\n\tlet vector = Vector2D(1, 1);\n\n\t// now left shifting a vector works\n\tprintln!(\"{:?}\", vector << 10); // prints Vector2D(1024, 1024)\n\tprintln!(\"{:?}\", vector.shl(10)); // prints Vector2D(1024, 1024)\n"
                ]
            },
            "Shr": {
                "implementor": [
                    "I can be right shifted using the >> sign or the shr() method.",
                    "I can also be right shifted using any other specific type, and not only myself, as it dependes on how Shr was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of right shifting, as that also dependes on how Shr was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Shr trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \">>\" sign)\n\t// as Vector2D, meaning we can only right shift it with a value of the same type\n\timpl Shr<i32> for Vector2D {\n\t\t// we define the output to be Vector2D\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the shr() method which takes an owned self\n\t\tfn shr(self, rhs: i32) -> Self::Output {\n\t\t\tVector2D(self.0 >> rhs, self.1 >> rhs)\n\t\t}\n\t}\n\n\t// we create our vector to right shift it\n\tlet vector = Vector2D(1024, 1024);\n\n\t// now right shifting a vector works\n\tprintln!(\"{:?}\", vector >> 10); // prints Vector2D(1, 1)\n\tprintln!(\"{:?}\", vector.shr(10)); // prints Vector2D(1, 1)\n"
                ]
            },
            "AddAssign": {
                "implementor": [
                    "I can be mutated to have a value added to me with one operation \"+=\" or the add_assign() method.",
                    "I can be \"addassigned\" any other type, and not only a similar type to myself, as it dependes on how AddAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we implement the AddAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the += sign / the thing that we will add)\n\t// as Vector2D, meaning we can only \"addassign\" it with a value of the same type\n\timpl AddAssign<Vector2D> for Vector2D {\n\t\t// we implement the add_assign() method\n\t\t// add_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn add_assign(&mut self, rhs: Vector2D) {\n\t\t\tself.0 += rhs.0;\n\t\t\tself.1 += rhs.1;\n\t\t}\n\t}\n\t// we create a mutable Vector2D\n\tlet mut a = Vector2D(1, 2);\n\n\t// we can now \"addassign\" it with a Vector2D\n\t// because we implemented AddAssign<Vector2D>\n\ta += Vector2D(1, 2);\n\tprintln!(\"{:?}\", a); // will output Vector2D(2, 4)\n\n\ta.add_assign(Vector2D(1, 2));\n\tprintln!(\"{:?}\", a); // will also output Vector2D(2, 4)\n\n\t// but this won't work\n\t// because we didn't implement AddAssign<i32>\n\ta += 2; // compiler error\n\ta.add_assign(2); // compiler error\n"
                ]
            },
            "SubAssign": {
                "implementor": [
                    "I can be mutated to have a value subtracted from me with one operation \"-=\" or the sub_assign() method.",
                    "I can be \"subassigned\" any other type, and not only a similar type to myself, as it dependes on how SubAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the SubAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the -= sign / the thing that we will subtract)\n\t// as Vector2D, meaning we can only \"subassign\" it with a value of the same type\n\timpl SubAssign<Vector2D> for Vector2D {\n\t\t// we implement the sub_assign() method\n\t\t// sub_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn sub_assign(&mut self, rhs: Vector2D) {\n\t\t\tself.0 -= rhs.0;\n\t\t\tself.1 -= rhs.1;\n\t\t}\n\t}\n\t// we create a mutable Vector2D\n\tlet mut a = Vector2D(1, 2);\n\n\t// we can now \"subassign\" it with a Vector2D\n\t// because we implemented SubAssign<Vector2D>\n\ta -= Vector2D(1, 2);\n\tprintln!(\"{:?}\", a); // will output Vector2D(0, 0)\n\n\ta.sub_assign(Vector2D(1, 2));\n\tprintln!(\"{:?}\", a); // will also output Vector2D(0, 0)\n\n\t// but this won't work\n\t// because we didn't implement SubAssign<i32>\n\ta -= 2; // compiler error\n\ta.sub_assign(2); // compiler error\n\n"
                ]
            },
            "DivAssign": {
                "implementor": [
                    "I can be mutated to the result of dividing myself with a value using one operation \"//=\" or the div_assign() method.",
                    "I can be \"divassigned\" any other type, and not only a similar type to myself, as it dependes on how DivAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the DivAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"/=\" sign / the thing that we will divide by)\n\t// as Vector2D, meaning we can only \"divassign\" it with a value of the same type\n\timpl DivAssign<Vector2D> for Vector2D {\n\t\t// we implement the div_assign() method\n\t\t// div_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn div_assign(&mut self, rhs: Vector2D) {\n\t\t\tself.0 /= rhs.0;\n\t\t\tself.1 /= rhs.1;\n\t\t}\n\t}\n\t// we create a mutable Vector2D\n\tlet mut a = Vector2D(1, 2);\n\n\t// we can now \"divassign\" it with a Vector2D\n\t// because we implemented DivAssign<Vector2D>\n\ta /= Vector2D(1, 2);\n\tprintln!(\"{:?}\", a); // will output Vector2D(1, 1)\n\n\ta.div_assign(Vector2D(1, 2));\n\tprintln!(\"{:?}\", a); // will also output Vector2D(1, 1)\n\n\t// but this won't work\n\t// because we didn't implement DivAssign<i32>\n\ta /= 2; // compiler error\n\ta.div_assign(2); // compiler error\n"
                ]
            },
            "MulAssign": {
                "implementor": [
                    "I can be mutated to the result of multiplying myself with a value using one operation \"*=\" or the mul_assign() method.",
                    "I can be \"mulassigned\" any other type, and not only a similar type to myself, as it dependes on how MulAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the MulAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"*=\" sign / the thing that we will multiply by)\n\t// as Vector2D, meaning we can only \"mulassign\" it with a value of the same type\n\timpl MulAssign<Vector2D> for Vector2D {\n\t\t// we implement the mul_assign() method\n\t\t// mul_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn mul_assign(&mut self, rhs: Vector2D) {\n\t\t\tself.0 *= rhs.0;\n\t\t\tself.1 *= rhs.1;\n\t\t}\n\t}\n\t// we create a mutable Vector2D\n\tlet mut a = Vector2D(1, 2);\n\n\t// we can now \"mulassign\" it with a Vector2D\n\t// because we implemented MulAssign<Vector2D>\n\ta *= Vector2D(1, 2);\n\tprintln!(\"{:?}\", a); // will output Vector2D(1, 4)\n\n\ta.mul_assign(Vector2D(1, 2));\n\tprintln!(\"{:?}\", a); // will also output Vector2D(1, 4)\n\n\t// but this won't work\n\t// because we didn't implement MulAssign<i32>\n\ta *= 2; // compiler error\n\ta.mul_assign(2); // compiler error\n"
                ]
            },
            "RemAssign": {
                "implementor": [
                    "I can be mutated to become the remainder of my division by any value using one operation \"*=\" or the rem_assign() method.",
                    "I can \"remassign\" by any other type, and not only a similar type to myself, as it dependes on how RemAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the RemAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"%=\" sign / the thing that we will divide by)\n\t// as Vector2D, meaning we can only \"remassign\" it with a value of the same type\n\timpl RemAssign<Vector2D> for Vector2D {\n\t\t// we implement the rem_assign() method\n\t\t// rem_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn rem_assign(&mut self, rhs: Vector2D) {\n\t\t\tself.0 %= rhs.0;\n\t\t\tself.1 %= rhs.1;\n\t\t}\n\t}\n\t// we create a mutable Vector2D\n\tlet mut a = Vector2D(1, 2);\n\n\t// we can now \"remassign\" it with a Vector2D\n\t// because we implemented RemAssign<Vector2D>\n\ta %= Vector2D(1, 2);\n\tprintln!(\"{:?}\", a); // will output Vector2D(0, 0)\n\n\ta.rem_assign(Vector2D(1, 2));\n\tprintln!(\"{:?}\", a); // will also output Vector2D(0, 0)\n\n\t// but this won't work\n\t// because we didn't implement RemAssign<i32>\n\ta %= 2; // compiler error\n\ta.rem_assign(2); // compiler error\n"
                ]
            },
            "ShlAssign": {
                "implementor": [
                    "I can be mutated to become the result of my left shifting by any value using one operation \"<<=\" or the shl_assign() method.",
                    "I can be \"shlassigned\" by any other type, and not only a similar type to myself, as it dependes on how ShlAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the ShlAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"<<=\" sign)\n\t// as i32, meaning we can only shift-left-assign it using an i32\n\timpl ShlAssign<i32> for Vector2D {\n\t\t// we implement the shl_assign() method\n\t\t// shl_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn shl_assign(&mut self, rhs: i32) {\n\t\t\tself.0 <<= rhs;\n\t\t\tself.1 <<= rhs;\n\t\t}\n\t}\n\n\t// we create our mutable vector\n\tlet mut vector = Vector2D(1, 1);\n\n\t// now shift-left-assigning a vector works\n\n\tvector <<= 10;\n\tprintln!(\"{:?}\", vector); // prints Vector2D(1024, 1024)\n\n\tvector.shl_assign(10);\n\tprintln!(\"{:?}\", vector); // prints Vector2D(1024, 1024)\n"
                ]
            },
            "ShrAssign": {
                "implementor": [
                    "I can be mutated to become the result of my right shifting by any value using one operation \"<<=\" or the shr_assign() method.",
                    "I can be \"shrassigned\" by any other type, and not only a similar type to myself, as it dependes on how ShrAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the ShrAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \">>=\" sign)\n\t// as i32, meaning we can only shift-right-assign it using an i32\n\timpl ShrAssign<i32> for Vector2D {\n\t\t// we implement the shr_assign() method\n\t\t// shr_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn shr_assign(&mut self, rhs: i32) {\n\t\t\tself.0 >>= rhs;\n\t\t\tself.1 >>= rhs;\n\t\t}\n\t}\n\n\t// we create our mutable vector\n\tlet mut vector = Vector2D(1024, 1024);\n\n\t// now shift-right-assigning a vector works\n\n\tvector >>= 10;\n\tprintln!(\"{:?}\", vector); // prints Vector2D(1, 1)\n\n\tvector.shr_assign(10);\n\tprintln!(\"{:?}\", vector); // prints Vector2D(1, 1)\n"
                ]
            },
            "Not": {
                "implementor": [
                    "I can use the Not symbol \"!\" for logical negation, or any custom implemented functionality.",
                    "I do not necessarily output a type similar to myself as the result of the operation, as that also dependes on how Not was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Not trait\n\t// with the functionality of the ! sign\n\t// to flip the sign of each component of the vector\n\timpl Not for Vector2D {\n\t\t// we define the output to be Vector2D\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the not() method which takes an owned self\n\t\tfn not(self) -> Self::Output {\n\t\t\tVector2D(self.0 * -1, self.1 * -1)\n\t\t}\n\t}\n\n\t// we create our vector\n\tlet vector = Vector2D(1, 1);\n\n\t// now using ! and .not() on the vector works\n\tprintln!(\"{:?}\", !vector); // prints Vector2D(-1, -1)\n\tprintln!(\"{:?}\", vector.not()); // prints Vector2D(-1, -1)\n"
                ]
            },
            "Neg": {
                "implementor": [
                    "I can use the Negation symbol \"-\" for negation, or any custom implemented functionality.",
                    "I do not necessarily output a type similar to myself as the result of the operation, as that also dependes on how Neg was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the Neg trait\n\t// with the functionality of the - sign\n\t// to negate the sign of each component of the vector\n\timpl Neg for Vector2D {\n\t\t// we define the output to be Vector2D\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the neg() method which takes an owned self\n\t\tfn neg(self) -> Self::Output {\n\t\t\tVector2D(self.0 * -1, self.1 * -1)\n\t\t}\n\t}\n\n\t// we create our vector\n\tlet vector = Vector2D(1, 1);\n\n\t// now using - and .neg() on the vector works\n\tprintln!(\"{:?}\", -vector); // prints Vector2D(-1, -1)\n\tprintln!(\"{:?}\", vector.neg()); // prints Vector2D(-1, -1)\n"
                ]
            },
            "Index": {
                "implementor": [
                    "I can be indexed like an array using the bracket syntax [] and the .index() method.",
                    "I can only be indexed immutably, meaning I can only be indexed to read values out of me.",
                    "My indexing can be a custom implemented functionality and is not necessarily array-like indexing, as it dependes on how Index was implemented for me"
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for some std collection types."
                ],
                "examples": [
                    "// we create a days of the week type\n\t#[derive(Debug, Clone, Copy)]\n\tenum Days {\n\t\tMonday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, NotADay,\n\t}\n\n\t// we implement the Index trait\n\t// to have the functionality of knowing\n\t// what day of the week will coincide with \n\t// whatever positive day displacement we provide\n\timpl Index<usize> for Days {\n\n\t\t// we define the output to be a Day\n\t\ttype Output = Days;\n\n\t\t// we implement the index() method\n\t\tfn index(&self, index: usize) -> &Self::Output {\n\n\t\t\t// we get the current day number\n\t\t\tlet current_day_number = self.clone() as usize + 1;\n\n\t\t\t// we find out which day of the week it coincides with\n\t\t\tmatch (index + current_day_number) % 7 {\n\t\t\t\t1 => &Days::Monday,\n\t\t\t\t2 => &Days::Tuesday,\n\t\t\t\t3 => &Days::Wednesday,\n\t\t\t\t4 => &Days::Thursday,\n\t\t\t\t5 => &Days::Friday,\n\t\t\t\t6 => &Days::Saturday,\n\t\t\t\t7 => &Days::Sunday,\n\t\t\t\t_ => &Days::NotADay,\n\t\t\t}\n\t\t}\n\t}\n\n\t// now we can find out what day of the week\n\t// is going to coincide with 100 days from Tuesday\n\tprintln!(\"{:?}\", Days::Tuesday[100]); // prints Thursday\n"
                ]
            },
            "IndexMut": {
                "implementor": [
                    "I can be indexed like an array using the bracket syntax [] and the .index_mut() method.",
                    "I can be indexed mutably, meaning I can be indexed to update values inside of me.",
                    "My indexing can be a custom implemented functionality and is not necessarily array-like indexing, as it dependes on how Index was implemented for me"
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for few std types."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t#[derive(Debug)]\n\tstruct DaysWorked {\n\t\tMonday: i32,\n\t\tTuesday: i32,\n\t\tWednesday: i32,\n\t\tThursday: i32,\n\t\tFriday: i32,\n\t\tSaturday: i32,\n\t\tSunday: i32,\n\t\tNotADay: i32,\n\t}\n\n\t// we first implement Index\n\t// IndexMut cannot be implemented for a type\n\t// without Index also being implemented\n\timpl Index<usize> for DaysWorked {\n\t\ttype Output = i32;\n\t\tfn index(&self, index: usize) -> &Self::Output {\n\t\t\tmatch index {\n\t\t\t\t1 => &self.Monday,\n\t\t\t\t2 => &self.Tuesday,\n\t\t\t\t3 => &self.Wednesday,\n\t\t\t\t4 => &self.Thursday,\n\t\t\t\t5 => &self.Friday,\n\t\t\t\t6 => &self.Saturday,\n\t\t\t\t_ => &self.Sunday,\n\t\t\t}\n\t\t}\n\t}\n\t// we implement the IndexMut trait\n\t// to have the functionality of changing\n\t// how many times we worked that day of the week\n\timpl IndexMut<usize> for DaysWorked {\n\t\t// we implement the index_mut() method\n\t\tfn index_mut(&mut self, index: usize) -> &mut Self::Output {\n\t\t\tmatch index {\n\t\t\t\t1 => &mut self.Monday,\n\t\t\t\t2 => &mut self.Tuesday,\n\t\t\t\t3 => &mut self.Wednesday,\n\t\t\t\t4 => &mut self.Thursday,\n\t\t\t\t5 => &mut self.Friday,\n\t\t\t\t6 => &mut self.Saturday,\n\t\t\t\t_ => &mut self.Sunday,\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// we create our DaysWorked variable\n\tlet mut days = DaysWorked {\n\t\tMonday:1,\n\t\tTuesday:3,\n\t\tWednesday:2,\n\t\tThursday:0,\n\t\tFriday:0,\n\t\tSaturday:0,\n\t\tSunday:0,\n\t\tNotADay:0,\n\t}\n\n\t// now we can change the number of times\n\t// we worked in Tuesday \n\tprintln!(\"{:?}\", days[2]); // it prints 3\n\n\t// we mutate days\n\tdays[2] = 10;\n\tprintln!(\"{:?}\", days[2]); // now it prints 10\n"
                ]
            },
            "BitAnd": {
                "implementor": [
                    "I am capable of using the bitwise AND operator via the \"&\" symbol and the .bitand() method.",
                    "I'm not restricted to only being \"ANDed\" with a variable of the same type, any other type can also be used as that depends on the how BitAnd was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of the AND operation, as that also dependes on how BitAnd was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t// we will implement BitAnd to operate on each\n\t// component of the vector\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the BitAnd trait for Vector2D\n\t// and specify the type of right hand side\n\t// (the thing to the right of the & sign)\n\t// as Vector2D, meaning we implement it to\n\t// only being \"anded\" with a variable of the same type\n\timpl BitAnd<Vector2D> for Vector2D {\n\t\t// we specify the type of the output of the operation\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the bitand() method\n\t\tfn bitand(self, rhs: Vector2D) -> Self::Output {\n\t\t\tVector2D(self.0 & rhs.0, self.1 & rhs.1)\n\t\t}\n\t}\n\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now \"and\" it with a Vector2D\n\t// because we implemented BitAnd<Vector2D>\n\t// \"anding\" a value with itself does nothing\n\tprintln!(\"{:?}\", a & Vector2D(1, 2)); // outputs Vector2D(1, 2)\n\tprintln!(\"{:?}\", a.bitand(Vector2D(1, 2))); // outputs Vector2D(1, 2)\n\n\t// but this won't work\n\t// because we didn't implement BitAnd<i32>\n\tprintln!(\"{:?}\", a & 2); // compiler error\n\tprintln!(\"{:?}\", a.bitand(2)); // compiler error\n"
                ]
            },
            "BitOr": {
                "implementor": [
                    "I am capable of using the bitwise OR operator via the \"|\" symbol and the .bitor() method.",
                    "I'm not restricted to only being \"ORed\" with a variable of the same type, any other type can also be used as that depends on the how BitOr was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of the OR operation, as that also dependes on how BitOr was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t// we will implement BitOr to operate on each\n\t// component of the vector\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the BitOr trait for Vector2D\n\t// and specify the type of right hand side\n\t// (the thing to the right of the | sign) as Vector2D\n\t// meaning we implement it to\n\t// only being \"ored\" with a variable of the same type\n\timpl BitOr<Vector2D> for Vector2D {\n\t\t// we specify the type of the output of the operation\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the bitor() method\n\t\tfn bitor(self, rhs: Vector2D) -> Self::Output {\n\t\t\tVector2D(self.0 | rhs.0, self.1 | rhs.1)\n\t\t}\n\t}\n\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now \"or\" it with a Vector2D\n\t// because we implemented BitOr<Vector2D>\n\t// \"oring\" a value with itself does nothing\n\tprintln!(\"{:?}\", a | Vector2D(1, 2)); // outputs Vector2D(1, 2)\n\tprintln!(\"{:?}\", a.bitor(Vector2D(1, 2))); // outputs Vector2D(1, 2)\n\n\t// but this won't work\n\t// because we didn't implement BitOr<i32>\n\tprintln!(\"{:?}\", a | 2); // compiler error\n\tprintln!(\"{:?}\", a.bitor(2)); // compiler error\n"
                ]
            },
            "BitXor": {
                "implementor": [
                    "I am capable of using the bitwise XOR operator via the \"^\" symbol and the .bitxor() method.",
                    "I'm not restricted to only being \"XORed\" with a variable of the same type, any other type can also be used as that depends on the how BitXor was implemented for me.",
                    "I do not necessarily output a type similar to myself as the result of the XOR operation, as that also dependes on how BitXor was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "\t// we create a new 2-Dimensional vector type\n\t// we will implement BitXor to operate on each\n\t// component of the vector\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the BitXor trait for Vector2D\n\t// and specify the type of right hand side\n\t// (the thing to the right of the ^ sign) as Vector2D\n\t// meaning we implement it to\n\t// only being \"xored\" with a variable of the same type\n\timpl BitXor<Vector2D> for Vector2D {\n\t\t// we specify the type of the output of the operation\n\t\ttype Output = Vector2D;\n\n\t\t// we implement the bitxor() method\n\t\tfn bitxor(self, rhs: Vector2D) -> Self::Output {\n\t\t\tVector2D(self.0 ^ rhs.0, self.1 ^ rhs.1)\n\t\t}\n\t}\n\n\t// we create a Vector2D\n\tlet a = Vector2D(1, 2);\n\n\t// we can now \"xor\" it with a Vector2D\n\t// because we implemented BitXor<Vector2D>\n\t// \"xoring\" a value with itself returns zero\n\tprintln!(\"{:?}\", a ^ Vector2D(1, 2)); // outputs Vector2D(0, 0)\n\tprintln!(\"{:?}\", a.bitxor(Vector2D(1, 2))); // outputs Vector2D(0, 0)\n\n\t// but this won't work\n\t// because we didn't implement BitXor<i32>\n\tprintln!(\"{:?}\", a ^ 2); // compiler error\n\tprintln!(\"{:?}\", a.bitxor(2)); // compiler error\n"
                ]
            },
            "BitAndAssign": {
                "implementor": [
                    "I can be mutated to become the result of applying the logical AND operation with me and any value using a single operation \"&=\" or the bitand_assign() method.",
                    "I can be \"and-assigned\" with any other type, and not only a similar type to myself, as it dependes on how BitAndAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t// we will implement BitAndAssign to operate on each\n\t// component of the vector\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the BitAndAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"&=\" sign)\n\t// as i32, meaning we can only and-assign it using an i32\n\timpl BitAndAssign<i32> for Vector2D {\n\t\t// we implement the bitand_assign() method\n\t\t// bitand_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn bitand_assign(&mut self, rhs: i32) {\n\t\t\tself.0 &= rhs;\n\t\t\tself.1 &= rhs;\n\t\t}\n\t}\n\n\t// we create our mutable vector\n\tlet mut vector = Vector2D(1, 1);\n\n\t// now and-assigning a vector with an i32 type works\n\t// 1 & 2 equals 0\n\t// so our operation should return Vector2D(0, 0)\n\tvector &= 2;\n\tprintln!(\"{:?}\", vector); // prints Vector2D(0, 0)\n\n\tvector.bitand_assign(2);\n\tprintln!(\"{:?}\", vector); // prints Vector2D(0, 0)\n"
                ]
            },
            "BitOrAssign": {
                "implementor": [
                    "I can be mutated to become the result of applying the logical OR operation with me and any value using a single operation \"|=\" or the bitor_assign() method.",
                    "I can be \"or-assigned\" with any other type, and not only a similar type to myself, as it dependes on how BitOrAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "// we create a new 2-Dimensional vector type\n\t// we will implement BitOrAssign to operate on each\n\t// component of the vector\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the BitOrAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"|=\" sign)\n\t// as i32, meaning we can only or-assign it using an i32\n\timpl BitOrAssign<i32> for Vector2D {\n\t\t// we implement the bitor_assign() method\n\t\t// bitor_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn bitor_assign(&mut self, rhs: i32) {\n\t\t\tself.0 |= rhs;\n\t\t\tself.1 |= rhs;\n\t\t}\n\t}\n\n\t// we create our mutable vector\n\tlet mut vector = Vector2D(1, 1);\n\n\t// now or-assigning a vector with an i32 type works\n\t// 1 | 2 equals 3\n\t// so our operation should return Vector2D(3, 3)\n\tvector |= 2;\n\tprintln!(\"{:?}\", vector); // prints Vector2D(3, 3)\n\n\tvector.bitor_assign(2);\n\tprintln!(\"{:?}\", vector); // prints Vector2D(3, 3)\n"
                ]
            },
            "BitXorAssign": {
                "implementor": [
                    "I can be mutated to become the result of applying the logical XOR operation with me and any value using a single operation \"^=\" or the bitxor_assign() method.",
                    "I can be \"xor-assigned\" with any other type, and not only a similar type to myself, as it dependes on how BitXorAssign was implemented for me."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented by default for all numeric types like i32, f64, ..etc."
                ],
                "examples": [
                    "\t// we create a new 2-Dimensional vector type\n\t// we will implement BitXorAssign to operate on each\n\t// component of the vector\n\t#[derive(Debug)]\n\tstruct Vector2D(i32, i32);\n\n\t// we implement the BitXorAssign trait\n\t// and specify the type of right hand side\n\t// (the thing to the right of the \"^=\" sign)\n\t// as i32, meaning we can only or-assign it using an i32\n\timpl BitXorAssign<i32> for Vector2D {\n\t\t// we implement the bitxor_assign() method\n\t\t// bitxor_assign only mutates the original type\n\t\t// so we need a &mut self\n\t\tfn bitxor_assign(&mut self, rhs: i32) {\n\t\t\tself.0 ^= rhs;\n\t\t\tself.1 ^= rhs;\n\t\t}\n\t}\n\n\t// we create our mutable vector\n\tlet mut vector = Vector2D(1, 1);\n\n\t// now xor-assigning a vector with an i32 type works\n\t// 1 ^ 2 equals 3\n\t// so our operation should return Vector2D(3, 3)\n\tvector ^= 2;\n\tprintln!(\"{:?}\", vector); // prints Vector2D(3, 3)\n\n\tvector.bitxor_assign(2);\n\tprintln!(\"{:?}\", vector); // prints Vector2D(3, 3)\n"
                ]
            },
            "Deref": {
                "implementor": [
                    "I can provide custom logic when I'm dereferenced with the \"*\" symbol through a .deref() method that I implement.",
                    "Every method that's available on the Target type I dereference to, is also available for me to use (Because I dereference to that Target, I do not actually implement these methods).",
                    "The compiler will automatically coerce me (convert me) into my Deref Target type If I'm in a place where that type is expected but I'm there instead (this is called Deref Coercion).",
                    "The compiler only coerces me when I'm a reference, (It only coerces &Me => &Target), it does not coerce me when I'm not a reference (coercing Me => Target does not happen).",
                    "I am a smart pointer (This is the convention that's expected, Deref and DerefMut are traits for smart pointers, but this is not an enforced rule)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for all smart pointer types/async/sync primitives.",
                    "I handle dereferencing in immutable contexts (reading data).",
                    "I appear like I provide inheritance for Rust types, but I do not, I provide automatic conversion (dereferencing)."
                ],
                "examples": [
                    "// we create a type NumBox\n\tstruct NumBox {\n\t\tnum: i32,\n\t}\n\t// we implement Deref for NumBox\n\t// to dereference into its inner num field\n\timpl Deref for NumBox {\n\t\ttype Target = i32;\n\t\tfn deref(&self) -> &Self::Target {\n\t\t\t// we return a reference to the inner field\n\t\t\t&self.num\n\t\t}\n\t}\n\n\t// we create our NumBox instance\n\tlet numbox = NumBox { num: 10 };\n\n\t// we dereference it here\n\t// dereferencing it automatically calls the .deref() method\n\tlet num: i32 = *numbox;\n\n\t// the above line is equivalent to the following line\n\tlet num2: i32 = *Deref::deref(&numbox);\n\n\tprintln!(\"{:?}\", num); // prints 10\n\tprintln!(\"{:?}\", num2); // also prints 10\n\n\t// both of these next lines work\n\t// the first one is the default case\n\t// the second one is the rust compiler doing deref coercion\n\t// after realizing the annotated type is not the default type &NumBox\n\tlet a: &NumBox = &numbox;\n\tlet a: &i32 = &numbox;\n\n\t// the second line is just doing this\n\tlet a: &i32 = Deref::deref(&numbox);\n\t\n\t// this next line however does not work\n\t// the rust compiler does not do Coercion when the type is owned\n\tlet a: i32 = numbox; // compiler error\n\n\n\t// now we create a new trait and implement it for i32\n\t// the trait simply implements a function that prints \"Hi\"\n\ttrait new_trait {\n\t\tfn say_hi(&self) {}\n\t}\n\n\timpl new_trait for i32 {\n\t\tfn say_hi(&self) {\n\t\t\tprintln!(\"Hi\");\n\t\t}\n\t}\n\n\t// we try to call say_hi on numbox\n\t// and it shouldn't work because NumBox does not implement new_trait\n\t// only i32 implements new_trait\n\t// but because NumBox's dereferenced Target is an i32\n\t// the rust compiler dereferences numbox and finds num\n\t// and it sees that num is an i32 and it has that method\n\t// so it calls successfully\n\tnumbox.say_hi();\n\n\t// the above line is equivalent to the following\n\tnumbox.num.say_hi();\n"
                ]
            },
            "DerefMut": {
                "implementor": [
                    "I can provide custom logic when I'm dereferenced in mutable contexts (my values are being mutated/updated) with the \"*\" symbol through a .deref_mut() method that I implement.",
                    "Every method that's available on the Target type I dereference to, is also available for me to use (Because I dereference to that Target, I do not actually implement these methods).",
                    "The compiler will automatically coerce me (convert me) into my DerefMut Target type If I'm in a place where that type is expected but I'm there instead (this is called Mutable Deref Coercion).",
                    "The compiler only coerces me when I'm a mutable reference, (It only coerces &mut Me => &mut Target), it does not coerce me when I'm not a mutable reference (coercing Me => Target does not happen).",
                    "I am a smart pointer (This is the convention that's expected, Deref and DerefMut are traits for smart pointers, but this is not an enforced rule)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for all smart pointer types/async/sync primitives.",
                    "I am the version of the Deref trait that handles dereferencing in mutable contexts (mutating data)."
                ],
                "examples": [
                    "// we create a type NumBox\n\tstruct NumBox {\n\t\tnum: i32,\n\t}\n\t// we implement Deref for NumBox\n\t// (DerefMut requires Deref to be implemented)\n\timpl Deref for NumBox {\n\t\ttype Target = i32;\n\t\tfn deref(&self) -> &Self::Target {\n\t\t\t&self.num\n\t\t}\n\t}\n\n\t// we now implement DerefMut\n\timpl DerefMut for NumBox {\n\t\tfn deref_mut(&mut self) -> &mut Self::Target {\n\t\t\t// we return a mutable reference to the inner field\n\t\t\t&mut self.num\n\t\t}\n\t}\n\n\t// we create our mutable NumBox instance\n\tlet mut numbox = NumBox { num: 10 };\n\n\t// we mutably dereference it here\n\t// because we're dereferencing it here in a mutating context \n\t// (we're mutating/updating numbox's values) \n\t// it automatically calls the .deref_mut() method\n\t*numbox = 100;\n\n\t// the above line is equivalent to the following line\n\t*DerefMut::deref_mut(&mut numbox) = 100;\n\n\t// now the inner num field is updated \n\tprintln!(\"{:?}\", numbox.num); // this prints 100\n\tprintln!(\"{:?}\", numbox.num); // also prints 100\n\n\t// both of these next lines work\n\t// the first one is the default case\n\t// the second one is the rust compiler doing mutable deref coercion\n\t// after realizing the annotated type is not the default type &mut NumBox\n\tlet a: &mut NumBox = &mut numbox;\n\tlet a: &mut i32 = &mut numbox;\n\n\t// the second line is just doing this\n\tlet a: &mut i32 = DerefMut::deref_mut(&mut numbox);\n\n\t// this next line however does not work\n\t// the rust compiler does not do Coercion when the type is owned\n\tlet a: i32 = numbox; // compiler error\n\n\t// now we create a new trait and implement it for i32\n\t// the trait simply implements a function that prints \"Hi\"\n\ttrait new_trait {\n\t\tfn say_hi(&mut self) {}\n\t}\n\n\timpl new_trait for i32 {\n\t\tfn say_hi(&mut self) {\n\t\t\tprintln!(\"Hi\");\n\t\t}\n\t}\n\n\t// we try to call say_hi on numbox\n\t// and it shouldn't work because NumBox does not implement new_trait\n\t// only i32 implements new_trait\n\t// but because NumBox's dereferenced Target is an i32\n\t// the rust compiler mutably dereferences numbox and finds num\n\t// and it sees that num is an i32 and it has that method\n\t// so it calls successfully\n\tnumbox.say_hi();\n\n\t// the above line is equivalent to the following\n\tnumbox.num.say_hi();\n"
                ]
            },
            "RangeBounds": {
                "implementor": [
                    "I'm a Rust range, meaning I'm one of the six Rust ranges provided by the language: (..), (num..), (num..num), (num..=num), (..num), (num..=num).",
                    "I can also be a custom type that's not a Rust range that implements the RangeBounds trait.",
                    "I can be interrogated to find out what my bounds are (beginning and end of me).",
                    "I can find out whether these limits/end points are bounded or unbounded (go to infinity or not) and if they're not unbounded also whether they're included or excluded (end points as part of range or excluded)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because the contains() method is generic and trait object vtables do not handle monomorphization.",
                    "I am implemented for all the Rust std Range types."
                ],
                "examples": [
                    "// the RangeBounds trait uses the Bounds struct\n\t// in the std::ops module to communicate\n\t// the three cases of end point \n\t// Unbounded, Included(value), Excluded(value) \n\n\t// all Rust standard library ranges implement RangeBounds\n\n\tlet a: RangeFull =                   ..       ;\n\tlet b: RangeFrom<i32> =           100..       ; \n\tlet c: RangeTo<i32> =                ..100    ;\n\tlet d: Range<i32> =               100..100    ;\n\tlet e: RangeToInclusive<i32> =       ..=100   ;\n\tlet f: RangeInclusive<i32> =      100..=100   ;\n\n\tprintln!(\"{:?}\", RangeBounds::<i32>::end_bound(&a));   // prints Unbounded\n\tprintln!(\"{:?}\", RangeBounds::<i32>::start_bound(&b)); // prints Included(100)\n\tprintln!(\"{:?}\", RangeBounds::<i32>::end_bound(&c));   // prints Excluded(100)\n\n\t// the RangeBounds trait also has a contains() method\n\t// which returns whether the argument is included in the range\n\tprintln!(c.contains(&2));\t\t\t\t\t  // prints true "
                ]
            },
            "Drop": {
                "implementor": [
                    "I am automatically dropped by the rust compiler when i go out of scope.",
                    "I can have custom functionality or clean up logic implemented for me prior to me being dropped."
                ],
                "trait": [
                    "I am used to implement clean up functionalities for the resources that the type that implements me was using in its lifetime, like file handles, network sockets, etc..",
                    "My drop() method gets called automatically the type that implements me goes out of scope, I dont need to be explicitly called",
                    "Infact my drop method is not allowed to be explicitly called before the scope ends. For explicit dropping therefore, the std::mem::drop() method is used (it also executes the cleanup thats in ops::Drop)"
                ],
                "examples": [
                    "// we create a new type String_Wrapper\n\t#[derive(Debug)]\n\tstruct String_Wrapper(String);\n\n\t// we implement Drop for our type\n\t// with the only functionality\n\t// to do pseudo clean up work\n\t// and print that the variable is dropped\n\timpl Drop for String_Wrapper {\n\t\tfn drop(&mut self) {\n\t\t\tprintln!(\"pseudo-cleaning-up\");\n\t\t\tprintln!(\"String wrapper is dropped\");\n\t\t}\n\t}\n\n\t// we create a String_Wrapper variable\n\tlet mut s = String_Wrapper(String::from(\"string\"));\n\t\n\t// we are unable to explicitly call drop on s\n\t// because Rust does not allow that\n\ts.drop(); // this results in a compiler error\n\n\t// to drop our s variable manually\n\t// we instead use the drop function\n\t// on the mem module\n\t// so the following line successfully drops s\n\tstd::mem::drop(s);\n\t// \"pseudo-cleaning-up\" is printed\n\t// \"String wrapper is dropped\" is printed\n\n\t// s no longer exist, so this println wont compile\n\tprintln!(\"{:?}\", s); // compiler error\n\t\n\t\n\t// we create a new String_Wrapper variable s\n\tlet mut s = String_Wrapper(String::from(\"string\"));\n\n\n\t// now that the scope is at its end\n\t// s is dropped automatically by the Rust Compiler\n\n\t// \"pseudo-cleaning-up\" is printed\n\t// \"String wrapper is dropped\" is printed\n"
                ]
            },
            "Fn": {
                "implementor": [
                    "I'm a closure that runs many times without mutating the captured variables from its scope (I implement Fn).",
                    "I capture some environment values by reference non mutably.",
                    "FnMut has to also be implemented for me to work."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for every closure that does not mutate captured scope variables.",
                    "I am the least restrictive closure type.",
                    "My implementors can be used everywhere a closure is expected because I'm the least restrictive closure trait."
                ],
                "examples": [
                    "\n// we defind a function that takes an Fn\n\tfn takes_closure(mut closure: impl Fn()) {\n\t\t// it just runs it\n\t\tclosure();\n\t}\n\t\n\t// we define a scope variable \n\t// that will be captured by our closure\n\tlet a = String::from(\"a\");\n\t// we define a closure that just drops the captured String\n\t// and because it drops the String\n\t// the compiler automatically implements FnOnce\n\t// and the String is moved inside the closure\n\tlet closure_once = || mem::drop(a);\n\t\n\t// we define another scope variable \n\t// that will be captured by our closure\n\tlet mut b = String::from(\"b\");\n\t// but this time in our closure \n\t// we mutate it instead of dropping it\n\t// and because the compiler sees that we only mutated it\n\t// it doesn't implement FnOnce and only implements FnMut\n\tlet closure_many_times_mut = || b.push_str(\"b\");\n\t\n\t// we define another scope variable \n\t// that will be captured by our closure\n\tlet c = String::from(\"c\");\n\t// but this time our closure  \n\t// doesn't mutate it, it only reads it \n\t// and because the compiler sees that we did not change it\n\t// it doesn't implement FnOnce nor FnMut\n\t// it only implements Fn\n\tlet closure_many_times = || println!(\"{:?}\", c);\n\n\t// we see that we can't pass an FnOnce to our function \n\t// because FnOnce only runs one time \n\t// and we explicitly specify a closure that runs many times\n\ttakes_closure(closure_once); // compiler error\n\t\n\t// we see that we also can't pass our FnMut to our function \n\t// because FnMut cannot accomodate shared access \n\t// and we explicitly specify a closure that requires that\n\ttakes_closure(closure_many_times_mut); // compiler error\n\n // we pass our Fn closure and it works \n\ttakes_closure(closure_many_times); \n"
                ]
            },
            "FnMut": {
                "implementor": [
                    "I'm a closure that runs many times and mutates captured variables from its scope (I implement FnMut).",
                    "I might also be a closure that runs many time and without mutating the environment (I implement FnMut along with Fn).",
                    "I capture some environment values by reference mutably.",
                    "FnOnce has to also be implemented for me to work."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for every closure that mutates captured scope variables.",
                    "I am implemented for every Fn closure (closures that do not mutate their data but run many times).",
                    "My implementors can not be used where implementors of Fn are expected, because being expected to allow shared access (borrowing) when I am only capable of providing exclusive access (mutable borrowing) is destructive (Rust will not allow this anyways), but the other way around is allowed because any closure that can accomodate shared access can also accomodate exclusive access."
                ],
                "examples": [
                    "// we defind a function that takes an FnMut\n\tfn takes_closure(mut closure: impl FnMut()) {\n\t\t// it just runs it\n\t\tclosure();\n\t}\n\t\n\t// we define a scope variable \n\t// that will be captured by our closure\n\tlet a = String::from(\"a\");\n\t// we define a closure that just drops the captured String\n\t// and because it drops the String\n\t// the compiler automatically implements FnOnce\n\t// and the String is moved inside the closure\n\tlet closure_once = || mem::drop(a);\n\t\n\t// we define another scope variable \n\t// that will be captured by our closure\n\tlet mut b = String::from(\"b\");\n\t// but this time in our closure \n\t// we mutate it instead of dropping it\n\t// and because the compiler sees that we only mutated it\n\t// it doesn't implement FnOnce and only implements FnMut\n\tlet closure_many_times_mut = || b.push_str(\"b\");\n\t\n\t// we define another scope variable \n\t// that will be captured by our closure\n\tlet c = String::from(\"c\");\n\t// but this time our closure  \n\t// doesn't mutate it, it only reads it \n\t// and because the compiler sees that we did not change it\n\t// it doesn't implement FnOnce nor FnMut\n\t// it only implements Fn\n\tlet closure_many_times = || println!(\"{:?}\", c);\n\n\t// we see that we can't pass an FnOnce to our function \n\t// because FnOnce only runs one time \n\t// and we explicitly specify a closure that runs many times mutably\n\ttakes_closure(closure_once); // compiler error\n\t\n\t// we pass our FnMut closure and it works \n\ttakes_closure(closure_many_times_mut); \n\n\t// we also pass our closure that runs many times \n\t// but does not mutate its captured values (Fn) \n\t// and it also works because Fn implements FnMut\n\ttakes_closure(closure_many_times); \n\n"
                ]
            },
            "FnOnce": {
                "implementor": [
                    "I'm a closure that can run *at least* one time.",
                    "I might be a closure that can run *Only one time* (I implement FnOnce only).",
                    "I might also be a closure that runs many times while mutating the environment (I implement FnOnce along with FnMut).",
                    "I might also be a closure that runs many time and without mutating the environment (I implement FnOnce along with FnMut along with Fn).",
                    "I capture some environment values by value (I move and own some values from my scope)."
                ],
                "trait": [
                    "I can't be derived.",
                    "I am implemented for all closure types because all closures can run at least one time.",
                    "My implementors can not be used where implementors of FnMut or Fn are expected, because being expected to run many times when I allow running only once is destructive (Rust will not allow this anyways), but the other way around is allowed because any closure that can run many times is capable of running one time."
                ],
                "examples": [
                    "// we defind a function that takes an FnOnce\n\tfn takes_closure(closure: impl FnOnce()) {\n\t\t// it just runs it\n\t\tclosure();\n\t}\n\t\n\t// we define a scope variable \n\t// that will be captured by our closure\n\tlet a = String::from(\"a\");\n\t// we define a closure that just drops the captured String\n\t// and because it drops the String\n\t// the compiler automatically implements FnOnce\n\t// and the String is moved inside the closure\n\tlet closure_once = || mem::drop(a);\n\t\n\t// we define another scope variable \n\t// that will be captured by our closure\n\tlet mut b = String::from(\"b\");\n\t// but this time in our closure \n\t// we mutate it instead of dropping it\n\t// and because the compiler sees that we only mutated it\n\t// it doesn't implement FnOnce and only implements FnMut\n\tlet closure_many_times_mut = || b.push_str(\"b\");\n\t\n\t// we define another scope variable \n\t// that will be captured by our closure\n\tlet c = String::from(\"c\");\n\t// but this time our closure  \n\t// doesn't mutate it, it only reads it \n\t// and because the compiler sees that we did not change it\n\t// it doesn't implement FnOnce nor FnMut\n\t// it only implements Fn\n\tlet closure_many_times = || println!(\"{:?}\", c);\n\n\t// and all of them can be passed to our function\n\t// because FnOnce is the base closure trait\n\ttakes_closure(closure_once);\n\t\n\t// a closure that runs many times \n\t// and mutates its captured values (FnMut)\n\t// also works becaue FnMut implements FnOnce\n\ttakes_closure(closure_many_times_mut); \n\n\t// a closure that runs many times \n\t// and does not mutate its captured values (Fn) also works \n\t// because Fn implements FnMut which implements FnOnce\n\ttakes_closure(closure_many_times); \n"
                ]
            }
        }
    },
    "str": {
        "introductory": "I contain str traits",
        "traits": {
            "FromStr": {
                "implementor": [
                    "I can be created from a string slice using a .from_str() that I provide.",
                    "The operation of creating me might fail."
                ],
                "trait": [
                    "I can't be derived.",
                    "I can't create or be part of a trait object (not Object-Safe), because I require the type I'm implemented for to have a Size known at compile time, and trait objects are Dynamically Sized Types, so the compiler will not be able to implement the FromStr trait for the trait object.",
                    "I allow failure, so I return a Result."
                ],
                "examples": [
                    "// we create our struct \n\t#[derive(Debug)]\n\tstruct NumBox { num: i32 }\n\t\n\t// we define an error type \n\t// to use in the FromStr associated error type \n\t#[derive(Debug)]\n\tstruct Error;\n\n\t// we implement FromStr for NumBox\n\t// to be able to create a NumBox from an &str\n\timpl FromStr for NumBox {\n\t\ttype Err = Error;\n\t\tfn from_str(s: &str) -> Result<Self, Self::Err> {\n\t\t\tOk(Self {\n\t\t\t\t// we just parse whatever &str we got\n\t\t\t\tnum: str::parse::<i32>(&s).unwrap(),\n\t\t\t})\n\t\t}\n\t}\n\n\t// Now we can create a NumBox from an &str\n\tlet numbox = NumBox::from_str(\"10\").unwrap();\n\t\n\t// and it successfully works\n\tprintln!(\"{numbox:?}\"); // prints NumBox { num: 10 }\n"
                ]
            }
        }
    },
    "any": {
        "introductory": "I emulate dynamic typing like in higher level languages via the Any trait",
        "traits": {
            "Any": {
                "implementor": [
                    "I have access to a .type_id() method to figure out what type I am at runtime.",
                    "I can figure out what type I am when I am inside generice code where type data is lost."
                ],
                "trait": [
                    "Because I am implemented for every type in the Rust language I can be used to emulate dynamic typing like in higher level languages by specifying the type of any type of data as &dyn any."
                ],
                "examples": [
                    "// String implements Any\n\tlet any_type: &dyn Any = &String::from(\"a\");\n\t\n\t// i32 implements Any\n\tlet any_type: &dyn Any = &2;\n\t\n\t// Vec implements Any\n\tlet any_type: &dyn Any = &vec![1, 2, 3, 4];\n\t\n\t// accepts any type as an argument\n\t// does not know what type it got\n\t// uses type_id() to figure that out at runtime\n\tfn is_string_or_not(any_type: &dyn Any) {\n\t\tprintln!(\"{}\", TypeId::of::<String>() == any_type.type_id());\n\t}\n\t\n\t// accepts String argument, finds out it's String\n\tis_string_or_not(&String::from(\"\"));\n\t    \n\t// accepts i32 argument, finds out it's not String\n\tis_string_or_not(&2);\n\t    \n\t// accepts Vec<i32> argument, finds out it's not String\n\tis_string_or_not(&vec![1, 2, 3]);"
                ]
            }
        }
    }
}